---
title: Referência de operadores físicos e lógicos de plano de execução | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
f1_keywords:
- sql12.swb.showplan.nestedloops.f1
- sql12.swb.showplan.dynamic.f1
- sql12.swb.showplan.tableinsert.f1
- sql12.swb.showplan.remoteinsert.f1
- sql12.swb.showplan.lazyspool.f1
- sql12.swb.showplan.RIDLookup
- sql12.swb.showplan.hashmatchteam.f1
- sql12.swb.showplan.tablespool.f1
- sql12.swb.showplan.print.f1
- sql12.swb.showplan.clusteredindexupdate.f1
- sql12.swb.showplan.assert.f1
- sql12.swb.showplan.columnstoreindexscan.f1
- sql12.swb.showplan.tablevaluedfunction.f1
- sql12.swb.showplan.split.f1
- sql12.swb.showplan.union.f1
- sql12.swb.showplan.clusteredindexseek.f1
- sql12.swb.showplan.indexspool.f1
- sql12.swb.showplan.indexinsert.f1
- sql12.swb.showplan.clusteredindexscan.f1
- sql12.swb.showplan.buildhash.f1
- sql12.swb.showplan.clusteredindexmerge.f1
- sql12.swb.showplan.sequence.f1
- sql12.swb.showplan.hashmatchroot.f1
- sql12.swb.showplan.columnstoreindexupdate.f1
- sql12.swb.showplan.rightsemijoin.f1
- sql12.swb.showplan.fetchquery.f1
- sql12.swb.showplan.distinct.f1
- sql12.swb.showplan.hashmatch.f1
- sql12.swb.showplan.segment.f1
- sql12.swb.showplan.top.f1
- sql12.swb.showplan.columnstoreindexdelete.f1
- sql12.swb.showplan.gatherstreams.f1
- sql12.swb.showplan.remotedelete.f1
- sql12.swb.showplan.insert.f1
- sql12.swb.showplan.declare.f1
- sql12.swb.showplan.snapshot.f1
- sql12.swb.showplan.assign.f1
- sql12.swb.showplan.intrinsic.f1
- sql12.swb.showplan.mergejoin.f1
- sql12.swb.showplan.concatenation.f1
- sql12.swb.showplan.rowcountspool.f1
- sql12.swb.showplan.parametertablescan.f1
- sql12.swb.showplan.indexscan.f1
- sql12.swb.showplan.while.f1
- sql12.swb.showplan.columnstoreindexinsert.f1
- sql12.swb.showplan.tablemerge.f1
- sql12.swb.showplan.spool.f1
- sql12.swb.showplan.streamaggregate.f1
- sql12.swb.showplan.update.f1
- sql12.swb.showplan.innerjoin.f1
- sql12.swb.showplan.flowdistinct.f1
- sql12.swb.showplan.tableupdate.f1
- sql12.swb.showplan.result.f1
- sql12.swb.showplan.bitmap.f1
- sql12.swb.showplan.remoteindexseek.f1
- sql12.swb.showplan.populationquery.f1
- sql12.swb.showplan.rightouterjoin.f1
- sql12.swb.showplan.columnstoreindexmerge.f1
- sql12.swb.showplan.remotescan.f1
- sql12.swb.showplan.remoteupdate.f1
- sql12.swb.showplan.keyset.f1
- sql12.swb.showplan.collapse.f1
- sql12.swb.showplan.arithmeticexpression.f1
- sql12.swb.showplan.clusteredindexinsert.f1
- sql12.swb.showplan.computescalar
- sql12.swb.showplan.sort.f1
- sql12.swb.showplan.locate.f1
- sql12.swb.showplan.constantscan.f1
- sql12.swb.showplan.computescalar.f1
- sql12.swb.showplan.indexseek.f1
- sql12.swb.showplan.leftsemijoin.f1
- sql12.swb.showplan.leftantisemijoin.f1
- sql12.swb.showplan.fullouterjoin.f1
- sql12.swb.showplan.filter.f1
- sql12.swb.showplan.indexdelete.f1
- sql12.swb.showplan.repartitionstreams.f1
- sql12.swb.showplan.crossjoin.f1
- sql12.swb.showplan.mergeinterval.f1
- sql12.swb.showplan.bookmarklookup.f1
- sql12.swb.showplan.convert.f1
- sql12.swb.showplan.refreshquery.f1
- sql12.swb.showplan.distinctsort.f1
- sql12.swb.showplan.leftouterjoin.f1
- sql12.swb.showplan.rightantisemijoin.f1
- sql12.swb.showplan.deletedscan.f1
- sql12.swb.showplan.udx.f1
- sql12.swb.showplan.broadcast.f1
- sql12.swb.showplan.delete.f1
- sql12.swb.showplan.aggregate.f1
- sql12.swb.showplan.setfunction.f1
- sql12.swb.showplan.switch.f1
- sql12.swb.showplan.remoteindexscan.f1
- sql12.swb.showplan.eagerspool.f1
- sql12.swb.showplan.indexupdate.f1
- sql12.swb.showplan.keylookup.f1
- sql12.swb.showplan.branchrepartition.f1
- sql12.swb.showplan.rank.f1
- sql12.swb.showplan.tablescan.f1
- sql12.swb.showplan.distributestreams.f1
- sql12.swb.showplan.logrowscan.f1
- sql12.swb.showplan.parallelism.f1
- sql12.swb.showplan.bitmapcreate.f1
- sql12.swb.showplan.insertedscan.f1
- sql12.swb.showplan.tabledelete.f1
- sql12.swb.showplan.clusteredindexdelete.f1
- sql12.swb.showplan.remotequery.f1
- sql12.swb.showplan.if.f1
- sql12.swb.showplan.cache.f1
- sql12.swb.showplan.partialaggregate.f1
- sql12.swb.showplan.sql.f1
helpviewer_keywords:
- execution plans [SQL Server], operators
- ActualRows attribute
- reading execution plan output
- ActualRewinds attribute
- ActualEndOfScans attribute
- query tuning [SQL Server]
- mapping operators [SQL Server]
- operators [Database Engine query tuning]
- logical operators [SQL Server], execution plans
- logical operators [SQL Server], listed
- physical operators [SQL Server]
- ActualRebinds attribute
- execution plans [SQL Server], reading output
ms.assetid: e43fd0fe-5ea7-4ffe-8d52-759ef6a7c361
author: rothja
ms.author: jroth
manager: craigg
ms.openlocfilehash: e4e45de57f4ea1ea88b72df7190e5ec8c3a1f768
ms.sourcegitcommit: 6fd8c1914de4c7ac24900fe388ecc7883c740077
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 04/26/2020
ms.locfileid: "62627088"
---
# <a name="showplan-logical-and-physical-operators-reference"></a>Referência de operadores físicos e lógicos de plano de execução
  Os operadores descrevem como o [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] executa uma consulta ou uma instrução DML (Linguagem de Manipulação de Dados). O otimizador de consultas usa os operadores para criar um plano de consulta a fim de criar o resultado especificado na consulta ou para executar a operação especificada na instrução DML. O plano de consulta é uma árvore que consiste em operadores físicos. Você pode exibir o plano de consulta usando as instruções SET SHOWPLAN, as opções de plano de execução gráfica no [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]ou as classes de evento do Plano de Execução do SQL Server Profiler.  
  
 Os operadores são classificados como lógicos e físicos.  
  
 **Operadores lógicos**  
 Os operadores lógicos descrevem a operação algébrica relacional usada para processar uma instrução. Em outras palavras, operadores lógicos descrevem conceitualmente qual operação precisa ser executada.  
  
 **Operadores físicos**  
 Os operadores físicos implementam a operação descrita pelos operadores lógicos. Cada operador físico é um objeto ou uma rotina que executa uma operação. Por exemplo, alguns operadores físicos acessam colunas ou linhas de uma tabela, índice ou exibição. Outros operadores físicos executam outras operações como cálculos, agregações, verificações da integridade de dados ou junções. Os operadores físicos possuem custos associados.  
  
 Os operadores físicos iniciam, coletam dados e fecham. Especificamente, o operador físico pode responder às três chamadas de método abaixo:  
  
-   **Init()** : o método **Init()** faz com que um operador físico se inicialize e define quaisquer estruturas de dados necessárias. O operador físico pode receber muitas chamadas **Init()** ; entretanto, um operador físico costuma receber somente uma.  
  
-   **GetNext()** : o método **GetNext()** faz um operador físico obter a primeira linha de dados ou a subsequente. O operador físico pode receber zero ou muitas chamadas **GetNext()** .  
  
-   **Close()** : o método **Close()** faz um operador físico executar algumas operações de limpeza total e se desligar. Um operador físico só recebe uma chamada **Close()** .  
  
 O método **GetNext()** retorna uma linha de dados e o número de vezes em que é chamado aparece como **ActualRows** na saída do Plano de Execução que é produzida usando as opções SET STATISTICS PROFILE ON ou SET STATISTICS XML ON. Para obter mais informações sobre essas opções SET, veja [SET STATISTICS PROFILE &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-profile-transact-sql) e [SET STATISTICS XML &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-xml-transact-sql).  
  
 Os contadores **ActualRebinds** e **ActualRewinds** exibidos na saída do Plano de Execução referem-se ao número de vezes que o método **Init()** é chamado. A menos que um operador esteja no lado interno de uma junção de loop, **ActualRebinds** será igual a um e **ActualRewinds** será igual a zero. Se um operador estiver no lado interno de uma junção de loop, a soma do número de reassociações e retrocessos deve ser igual ao número de linhas processadas no lado externo da junção. Uma reassociação significa que um ou mais dos parâmetros correlatos da junção se alterou e o lado interno deve ser reavaliado. Um retrocesso significa que nenhum dos parâmetros correlatos se alterou e o conjunto de resultados interno anterior pode ser usado novamente.  
  
 **ActualRebinds** e **ActualRewinds** estão presentes na saída do Plano de Execução XML produzida usando a opção SET STATISTICS XML ON. Eles são populados apenas para os operadores de spool de `Remote Query`índice não **clusterizado**, `Sort`de contagem de **linhas**, de spool de **tabela**e de **função com valor de tabela** . **ActualRebinds** e **ActualRewinds** também podem ser populados `Assert` para os operadores de **filtro** e quando o atributo **startuptable** é definido como true.  
  
 Quando **ActualRebinds** e **ActualRewinds** estiverem presentes em um Plano de Execução XML, serão comparáveis a **EstimateRebinds** e **EstimateRewinds**. Quando estiverem ausentes, o número estimado de linhas (**EstimateRows**) será comparável ao número de linhas real (**ActualRows**). Observe que a saída gráfica real do Plano de Execução exibe zeros para reassociações e retrocessos reais quando eles estão ausentes.  
  
 Um contador relacionado, **ActualEndOfScans**, só está disponível quando a saída do Plano de Execução é produzida usando a opção SET STATISTICS XML ON. Sempre que um operador físico chega ao término de seu fluxo de dados, esse contador é incrementado em um. Um operador físico pode chegar ao término de seu fluxo de dados zero, uma ou mais vezes. Como com as reassociações e os retrocessos, o número de término de exames só poderá ser superior a um se o operador estiver no lado interno de uma junção de loop. O número de término de exames deveria ser inferior ou igual à soma do número de reassociações e retrocessos.  
  
## <a name="mapping-physical-and-logical-operators"></a>Mapeando operadores físicos e lógicos  
 O otimizador de consulta cria um plano de consulta como uma árvore que consiste em operadores lógicos. Depois de criar o plano, o otimizador de consulta escolhe o operador físico mais eficiente para cada operador lógico. O otimizador de consulta usa uma abordagem baseada em custos para determinar qual operador físico implementará um operador lógico.  
  
 Normalmente, uma operação lógica pode ser implementada por diversos operadores físicos. Em alguns casos raros, porém, um operador físico também pode implementar diversas operações lógicas.  
  
## <a name="operator-descriptions"></a>Descrições dos operadores  
 Esta seção contém descrições dos operadores lógicos e físicos.  
  
|Ícone do plano de execução gráfica|Operador de plano de execução|DESCRIÇÃO|  
|-----------------------------------|-----------------------|-----------------|  
|Nenhum|`Aggregate`|O operador `Aggregate` calcula uma expressão que contém MIN, MAX, SUM, COUNT ou AVG. O operador `Aggregate` pode ser um operador lógico ou um operador físico.|  
|![Ícone do operador Arithmetic expression](../../2014/database-engine/media/arithmetic-expression-32x-2.gif "Ícone do operador Arithmetic expression")|`Arithmetic Expression`|O operador `Arithmetic Expression` computa um valor novo de valores existentes em uma linha. `Arithmetic Expression` não é usado no [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].|  
|![Ícone do operador Assert](../../2014/database-engine/media/assert-32x.gif "Ícone do operador Assert")|`Assert`|O operador `Assert` verifica uma condição. Por exemplo, ele valida integridade referencial ou assegura que uma subconsulta escalar retorne uma linha. Para cada linha de entrada, `Assert` o operador avalia a expressão na `Argument` coluna do plano de execução. Se essa expressão for avaliada como NULL, a linha será passada pelo operador `Assert` e a execução de consulta continuará. Se essa expressão for avaliada como um valor não nulo, será gerado um erro apropriado. O operador `Assert` é um operador físico.|  
|![Ícone do elemento de linguagem Assign](../../2014/database-engine/media/assign-32.gif "Ícone do elemento de linguagem Assign")|`Assign`|O operador `Assign` atribui o valor de uma expressão ou constante a um variável. `Assign` é um elemento de linguagem.|  
|Nenhum|`Asnyc Concat`|O operador `Asnyc Concat` é usado somente em consultas remotas (consultas distribuídas). Ele tem *n* filhos e um nó pai. Normalmente, alguns dos filhos são computadores remotos que participam de uma consulta distribuída. `Asnyc Concat` emite chamadas `open()` simultaneamente a todos os filhos e aplica um bitmap a cada filho. Para cada bit que é um 1, `Async Concat` envia linhas de saída para o nó pai sob demanda.|  
|![Ícone do operador Bitmap](../../2014/database-engine/media/bitmap-32x.gif "Ícone do operador Bitmap")|`Bitmap`|[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]usa o `Bitmap` operador para implementar a filtragem de bitmap em planos de consulta paralelos. A filtragem de bitmap acelera a execução da consulta eliminando linhas com valores de chave que não podem produzir nenhum registro de junção antes de passar `Parallelism` as linhas por meio de outro operador, como o operador. Um filtro de bitmap usa uma representação compacta de um conjunto de valores de uma tabela em uma parte da árvore de operador de uma segunda tabela em outra parte da árvore. Com a remoção de linhas desnecessárias previamente na consulta, os operadores subsequentes têm menos linhas para trabalhar e o desempenho geral da consulta melhora. O otimizador de consulta determina quando um bitmap é seletivo o bastante para ser útil e em quais operadores o filtro é aplicado. `Bitmap` é um operador físico.|  
|![Ícone do operador Bitmap](../../2014/database-engine/media/bitmap-32x.gif "Ícone do operador Bitmap")|`Bitmap Create`|O operador `Bitmap Create` aparece na saída do plano de execução onde os bitmaps são criados. `Bitmap Create` é um operador lógico.|  
|![Ícone do operador Bookmark lookup](../../2014/database-engine/media/bookmark-lookup-32x.gif "Ícone do operador Bookmark lookup")|`Bookmark Lookup`|O operador `Bookmark Lookup` usa um indicador (ID da fila ou chave de clustering) para pesquisar a linha correspondente na tabela ou índice clusterizado. A `Argument` coluna contém o rótulo de indicador usado para pesquisar a linha na tabela ou no índice clusterizado. A `Argument` coluna também contém o nome da tabela ou do índice clusterizado no qual a linha é pesquisada. Se a cláusula WITH PREFETCH aparecer na `Argument` coluna, o processador de consultas determinou que é ideal usar a pré-busca assíncrona (Read-Ahead) ao pesquisar indicadores na tabela ou no índice clusterizado.<br /><br /> `Bookmark Lookup` não é usado no [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)]. Em vez disso, `Clustered Index Seek` e `RID Lookup` fornecem funcionalidade de indicador de pesquisa. O operador `Key Lookup` também fornece essa funcionalidade.|  
|Nenhum|`Branch Repartition`|Às vezes, em um plano de consulta paralelo, há regiões conceituais de iteradores. Todos os iteradores dentro de tal região podem ser executados por threads paralelos. As próprias regiões devem ser executadas em série. Alguns dos iteradores `Parallelism` em uma região individual são chamados `Branch Repartition`. O iterador `Parallelism` no limite dessas duas regiões é chamado `Segment Repartition`. `Branch Repartition` e `Segment Repartition` são operadores lógicos.|  
|Nenhum|`Broadcast`|`Broadcast`tem um nó filho e *n* nós pai. `Broadcast` envia suas linhas de entrada para vários consumidores sob demanda. Cada consumidor adquire todas as linhas. Por exemplo, se todos os consumidores representarem lados de criação de uma junção hash, então serão criadas *n* cópias das tabelas de hash.|  
|![Ícone do operador Build hash](../../2014/database-engine/media/build-hash.gif "Ícone do operador Build hash")|`Build Hash`|Indica a criação de uma tabela de hash de lote para um índice columnstore xVelocity de memória otimizada.|  
|Nenhum|`Cache`|`Cache`é uma versão especializada do operador **spool** . Ele armazena somente uma linha de dados. `Cache` é um operador lógico. `Cache` não é usado no [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].|  
|![Ícone do operador Clustered index delete](../../2014/database-engine/media/clustered-index-delete-32x.gif "Ícone do operador Clustered index delete")|`Clustered Index Delete`|O `Clustered Index Delete` operador exclui linhas do índice clusterizado especificado na coluna Argument do plano de execução de consulta. Se um predicado WHERE: () estiver presente na coluna Argumento, somente as linhas que atenderem ao predicado serão excluídas.`Clustered Index Delete`  é um operador físico.|  
|![Ícone do operador Clustered index insert](../../2014/database-engine/media/clustered-index-insert-32x.gif "Ícone do operador Clustered index insert")|`Clustered Index Insert`|O `Clustered Index Insert` operador Showplan insere linhas de sua entrada no índice clusterizado especificado na coluna Argument. A coluna Argument também contém um predicado SET:(), que indica o valor para o qual cada coluna está definida. Se `Clustered Index Insert` não tiver filhos para inserir valores, a linha inserida será extraída `Insert` do próprio operador.`Clustered Index Insert`  é um operador físico.|  
|![Operador Clustered index merge](../../2014/database-engine/media/clustered-index-merge-32x.gif "Operador Clustered index merge")|**Clustered Index Merge**|O operador **Clustered Index Merge** aplica um fluxo de mesclagem de dados a um índice clusterizado. O operador exclui, atualiza ou insere linhas do índice clusterizado especificado na `Argument` coluna do operador. A operação real executada depende do valor de tempo de execução da coluna de **ação** especificada `Argument` na coluna do operador. **Clustered Index Merge** é um operador físico.|  
|![Ícone do operador Clustered index scan](../../2014/database-engine/media/clustered-index-scan-32x.gif "Ícone do operador Clustered index scan")|`Clustered Index Scan`|O `Clustered Index Scan` operador examina o índice clusterizado especificado na coluna Argument do plano de execução de consulta. Quando houver um predicado opcional WHERE:(), somente as linhas que atenderem ao predicado serão retornadas. Se a coluna Argument apresentar a cláusula ORDERED, o processador de consulta solicitou que a saída das linhas seja retornada na ordem em que o índice clusterizado as classificou. Se a cláusula ORDERED não estiver presente, o mecanismo de armazenamento examinará o índice em modo ótimo, sem necessariamente classificar a saída. `Clustered Index Scan` é um operador lógico e físico.|  
|![Ícone do operador Clustered index seek](../../2014/database-engine/media/clustered-index-seek-32x.gif "Ícone do operador Clustered index seek")|`Clustered Index Seek`|O `Clustered Index Seek` operador usa a capacidade de busca de índices para recuperar linhas de um índice clusterizado. A `Argument` coluna contém o nome do índice clusterizado que está sendo usado e o predicado Seek:(). O mecanismo de armazenamento usa o índice para processar somente as linhas que satisfazem esse predicado SEEK:(). Ele pode incluir também um predicado WHERE:(), onde o mecanismo de armazenamento avaliará em relação a todas as linhas que satisfizerem o predicado SEEK:(), mas isso é opcional e não usa índices para executar esse processo.<br /><br /> Se a `Argument` coluna contiver a cláusula ordenada, o processador de consultas determinou que as linhas devem ser retornadas na ordem em que o índice clusterizado as classificou. Se a cláusula ORDERED não estiver presente, o mecanismo de armazenamento pesquisará o índice em modo ótimo, sem necessariamente classificar a saída. Permitir que a saída retenha sua ordenação pode ser menos eficiente do que produzir saída não classificada. Quando a palavra-chave LOOKUP aparecer, então uma consulta de marcador está sendo executada. No [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] e em versões posteriores `Key Lookup` , o operador fornece a funcionalidade de pesquisa de indicador. `Clustered Index Seek` é um operador lógico e físico.|  
|![Ícone do operador Clustered index update](../../2014/database-engine/media/clustered-index-update-32x.gif "Ícone do operador Clustered index update")|`Clustered Index Update`|O `Clustered Index Update` operador atualiza as linhas de entrada no índice clusterizado especificado na `Argument` coluna. Se um predicado WHERE:() estiver presente, somente as linhas que atenderem a esse predicado serão atualizadas. Se um predicado SET:() estiver presente, cada coluna atualizada será definida com esse valor. Se um predicado DEFINE: () está presente, serão listados os valores que esse operador definir. Esses valores podem ser referenciados na cláusula SET ou em outro lugar dentro desse operador e em outro lugar dentro dessa consulta. `Clustered Index Update` é um operador lógico e físico.|  
|![Ícone do operador Collapse](../../2014/database-engine/media/collapse-32x.gif "Ícone do operador Collapse")|`Collapse`|O operador `Collapse` otimiza processamento de atualização. Quando uma atualização é executada, ela pode ser dividida (usando o operador `Split`) em uma exclusão e uma entrada. A `Argument` coluna contém uma cláusula Group by:() que especifica uma lista de colunas de chave. Se o processador de consultas encontrar linhas adjacentes que incluem e inserem os mesmos valores de chave, ele substituirá essas operações separadas por uma operação de atualização única e mais eficiente. `Collapse` é um operador lógico e físico.|  
|![Verificação de Índice Columnstore](../../2014/database-engine/media/columnstoreindexscan.gif "Verificação de Índice Columnstore")|`Columnstore Index Scan`|O `Columnstore Index Scan` operador verifica o índice columnstore especificado na `Argument` coluna do plano de execução de consulta.|  
|![Ícone do operador Compute scalar](../../2014/database-engine/media/compute-scalar-32x.gif "Ícone do operador Compute scalar")|`Compute Scalar`|O `Compute Scalar` operador avalia uma expressão para produzir um valor escalar calculado. Isso pode ser retornado ao usuário, ter referência em outro lugar na consulta, ou ambos. Um exemplo de ambos está em um predicado de filtro ou predicado de junção. `Compute Scalar` é um operador lógico e físico.<br /><br /> `Compute Scalar`os operadores que aparecem em planos de exibição gerados por SET STATISTICs XML podem não `RunTimeInformation` conter o elemento. Em planos de execução gráficos, **Linhas Reais**, **Religações Reais**e **Retrocessos Reais** podem estar ausentes na janela **Propriedades** quando a opção **Incluir Plano de Execução Real** estiver selecionada em [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]. Quando isto acontece, significa que, embora os operadores tenham sido usados no plano de consulta compilado, o trabalho foi executado por outros operadores no plano de consulta de tempo de execução. Observe também que o número de execuções na saída de plano de execução gerada por SET STATISTICS PROFILE é equivalente à soma de reassociações e retrocessos em planos de execução gerados por SET STATISTICS XML.|  
|![Ícone do operador Concatenation](../../2014/database-engine/media/concatenation-32x.gif "Ícone do operador Concatenation")|**Concatenação**|O operador **Concatenation** verifica várias entradas, retornando cada linha verificada. **Concatenation** normalmente é usado para implementar a construção UNION ALL [!INCLUDE[tsql](../includes/tsql-md.md)] . O operador físico **Concatenation** tem duas ou mais entradas e uma saída. Concatenation copia linhas do primeiro fluxo de entrada ao fluxo de saída e repete essa operação para cada fluxo de entrada adicional. **Concatenation** é um operador lógico e físico.|  
|![Ícone do operador Constant scan](../../2014/database-engine/media/constant-scan-32x.gif "Ícone do operador Constant scan")|`Constant Scan`|O `Constant Scan` operador apresenta uma ou mais linhas constantes em uma consulta. Um `Compute Scalar` operador é frequentemente usado depois de `Constant Scan` um para adicionar colunas a uma linha produzida pelo `Constant Scan` operador.|  
|![Ícone do elemento de linguagem Convert (mecanismo de banco de dados)](../../2014/database-engine/media/convert-32x.gif "Ícone do elemento de linguagem Convert (mecanismo de banco de dados)")|`Convert`|O operador `Convert` converte um tipo de dados escalar em outro. `Convert` é um elemento de linguagem.|  
|Nenhum|`Cross Join`|O operador `Cross Join` une cada linha da primeira entrada (superior) a cada linha da segunda entrada (inferior). `Cross Join` é um operador lógico.|  
|![Ícone do operador de cursor Cursor catchall](../../2014/database-engine/media/cursor-catch-all.gif "Ícone do operador de cursor Cursor catchall")|`catchall`|O ícone catchall é exibido quando a lógica que produz planos de execução gráficos não puder encontrar um ícone viável para o iterador. O ícone catchall não indica necessariamente uma condição de erro. Há três ícones catchall: azul (para iteradores), laranja (para cursores) e verde (para elementos de linguagem [!INCLUDE[tsql](../includes/tsql-md.md)] ).|  
|Nenhum|**Cursor**|Os operadores lógicos e físicos **Cursor** são usados para descrever como é executada uma consulta ou atualização que envolva operações de cursor. Os operadores físicos descrevem o algoritmo de implementação físico usado para processar o cursor; por exemplo, usando um cursor controlado por conjunto de chaves. Cada etapa na execução de um cursor envolve um operador físico. Os operadores lógicos descrevem uma propriedade do cursor, como quando o cursor é somente leitura.<br /><br /> Operadores lógicos incluem Asynchronous, Optimistic, Primary, Read Only, Scroll Locks, Secondary e Synchronous.<br /><br /> Operadores físicos incluem Dynamic, Fetch Query, Keyset, Population Query, Refresh Query e Snapshot.|  
|![Ícone do elemento de linguagem Declare](../../2014/database-engine/media/declare-32x.gif "Ícone do elemento de linguagem Declare")|`Declare`|O `Declare` operador aloca uma variável local no plano de consulta. `Declare` é um elemento de linguagem.|  
|![Ícone do operador Delete (mecanismo de banco de dados)](../../2014/database-engine/media/delete-32x.gif "Ícone do operador Delete (mecanismo de banco de dados)")|`Delete`|O `Delete` operador exclui de um objeto linhas que satisfazem o predicado `Argument` opcional na coluna.|  
|![Ícone do operador Delete scan](../../2014/database-engine/media/delete-scan-32x.gif "Ícone do operador Delete scan")|`Deleted Scan`|O operador `Deleted Scan` examina a tabela excluída em um gatilho.|  
|Nenhum|`Distinct`|O operador `Distinct` remove duplicatas de um conjunto de linhas ou de uma coleção de valores. `Distinct` é um operador lógico.|  
|Nenhum|`Distinct Sort`|O `Distinct Sort` operador lógico examina a entrada, removendo duplicatas e classificando as colunas especificadas no predicado ordem distinta por:() `Argument` da coluna. `Distinct Sort` é um operador lógico.|  
|![Ícone do operador de paralelismo Distribute streams](../../2014/database-engine/media/parallelism-distribute-stream.gif "Ícone do operador de paralelismo Distribute streams")|**Distribute Streams**|O operador **Distribute Streams** só é usado em planos de consulta paralelos. O operador **Distribute Streams** leva um fluxo de entrada simples de registros e produz fluxos de saída múltiplos. O conteúdo do registro e o formato não são alterados. Cada registro do fluxo de entrada aparece em um dos fluxos de saída. Este operador preserva automaticamente a ordem relativa dos registros de entrada nos fluxos de saída. Normalmente, são usadas operações de hash para decidir a qual fluxo de saída pertence um determinado registro de entrada.<br /><br /> Se a saída for particionada, a `Argument` coluna conterá um predicado:() de colunas de partição e as colunas de particionamento. **Distribute Streams** é um operador lógico|  
|![Ícone do operador de cursor Dynamic](../../2014/database-engine/media/dynamic-32x.gif "Ícone do operador de cursor Dynamic")|`Dynamic`|O operador `Dynamic` usa um cursor que pode ver todas as alterações feitas por outros.|  
|![Ícone do operador Spool](../../2014/database-engine/media/spool-32x.gif "Ícone do operador Spool")|**Eager Spool**|O operador de **spool adiantado** usa toda a entrada, armazenando cada linha em um objeto temporário oculto `tempdb` armazenado no banco de dados. Se o operador for rebobinar (por exemplo, por `Nested Loops` um operador), mas nenhuma reassociação for necessária, os dados em spool serão usados em vez de examinar novamente a entrada. Se a reassociação for necessária, os dados em spool serão descartados e o objeto de spool será recriado por meio do novo exame da entrada (religação). O operador **Eager Spool** cria seu arquivo de spool de maneira “ávida”, ou seja, cada vez que o operador pai do spool solicita a primeira linha, o operador de spool consome todas as linhas de seu operador de entrada e as armazena no spool. O**Eager Spool** é um operador lógico.|  
|![Ícone do operador de cursor Fetch query](../../2014/database-engine/media/fetch-query-32x.gif "Ícone do operador de cursor Fetch query")|`Fetch Query`|O operador `Fetch Query` recupera linhas quando é feita uma busca em um cursor.|  
|![Ícone do operador Filter (mecanismo de banco de dados)](../../2014/database-engine/media/filter-32x.gif "Ícone do operador Filter (mecanismo de banco de dados)")|**Filter**|O operador **Filter** examina a entrada, retornando apenas as linhas que satisfazem a expressão de filtro (predicado `Argument` ) que aparece na coluna.|  
|Nenhum|`Flow Distinct`|O operador lógico `Flow Distinct` examina a entrada, removendo duplicatas. Enquanto o `Distinct` operador consome todas as entradas antes de produzir qualquer saída, o operador **FlowDistinct** retorna cada linha conforme é obtido da entrada (a menos que essa linha seja uma duplicata; nesse caso, ela é descartada).|  
|Nenhum|`Full Outer Join`|O operador lógico `Full Outer Join` retorna cada linha que satisfaz o predicado de junção da primeira entrada (parte superior) associada a cada linha da segunda entrada (parte inferior). Ele também retorna linhas:<br /><br /> - Da primeira entrada que não teve nenhuma correspondência na segunda entrada.<br /><br /> - Da segunda entrada que não teve nenhuma correspondência na primeira entrada.<br /><br /> <br /><br /> A entrada que não contém os valores correspondentes é retornada como um valor nulo. `Full Outer Join` é um operador lógico.|  
|![Ícone do operador de paralelismo Gather streams](../../2014/database-engine/media/parallelism-32x.gif "Ícone do operador de paralelismo Gather streams")|**Gather Streams**|O operador **Gather Streams** só é usado em planos de consulta paralelos. O operador **Gather Streams** consome vários fluxos de entrada e produz um único fluxo de saída de registros ao combinar os fluxos de entrada. O conteúdo do registro e o formato não são alterados. Se este operador for preservador da ordem, todos os fluxos de entrada deverão ser ordenados. Se a saída for ordenada, a `Argument` coluna conterá um predicado order by:() e os nomes das colunas que estão sendo ordenadas. **Gather Streams** é um operador lógico.|  
|![Ícone do operador Hash match](../../2014/database-engine/media/hash-match-32x.gif "Ícone do operador Hash match")|`Hash Match`|O operador `Hash Match` cria uma tabela de hash computando um valor de hash para cada linha da entrada criada. Um predicado de HASH:() com uma lista de colunas usadas para criar um valor de `Argument` hash aparece na coluna. Então, para cada fila de sondagem (conforme aplicável), ela computa um valor de hash (usando a mesma função de hash) e procura correspondências na tabela de hash. Se um predicado residuais estiver presente (identificado por:() residuais `Argument` na coluna), esse predicado também deverá ser atendido para que as linhas sejam consideradas uma correspondência. O comportamento depende da operação lógica que está sendo executada:<br /><br /> Para qualquer junção, use a primeira entrada (superior) para criar a tabela de hash e a segunda (inferior) para sondar a tabela de hash. As correspondências de saída (ou não correspondências) conforme determinadas pelo tipo de junção. Se várias junções usam a mesma coluna de junção, essas operações serão agrupadas em uma equipe de hash.<br /><br /> Para os operadores distintos ou de agregação, use a entrada para criar a tabela de hash (removendo duplicatas e computando quaisquer expressões de agregação). Quando a tabela de hash for criada, verifique a tabela e saída de todas as entradas.<br /><br /> Para o operador de união, use a primeira entrada para criar a tabela de hash (removendo duplicatas). Use a segunda entrada (que não deve ter uma duplicata) para sondar a tabela de hash, retornando todas linhas sem correspondência e, então, verifique a tabela de hash e retorne todas as entradas.<br /><br /> <br /><br /> `Hash Match` é um operador físico.|  
|![Ícone do elemento de linguagem If](../../2014/database-engine/media/if-32x.gif "Ícone do elemento de linguagem If")|`If`|O operador `If` executa processamento condicional com base em uma expressão. `If` é um elemento de linguagem.|  
|Nenhum|`Inner Join`|O operador lógico `Inner Join` retorna cada linha que satisfaz a junção da primeira entrada (superior) com a segunda entrada (inferior).|  
|![Ícone do operador Insert (mecanismo de banco de dados)](../../2014/database-engine/media/insert-32x.gif "Ícone do operador Insert (mecanismo de banco de dados)")|`Insert`|O `Insert` operador lógico insere cada linha de sua entrada no objeto especificado na `Argument` coluna. O operador físico é o operador `Table Insert`, `Index Insert` ou `Clustered Index Insert`.|  
|![Ícone do operador Inserted scan](../../2014/database-engine/media/inserted-scan-32x.gif "Ícone do operador Inserted scan")|**Inserted Scan**|O operador **Inserted Scan** verifica a tabela **inserida** . O**Inserted Scan** é um operador lógico e físico.|  
|![Ícone do elemento de linguagem Intrinsic](../../2014/database-engine/media/intrinsic-32x.gif "Ícone do elemento de linguagem Intrinsic")|`Intrinsic`|O operador `Intrinsic` invoca uma função [!INCLUDE[tsql](../includes/tsql-md.md)] interna. `Intrinsic` é um elemento de linguagem.|  
|![Ícone do operador Iterator catchall](../../2014/database-engine/media/iterator-catch-all.gif "Ícone do operador Iterator catchall")|`Iterator`|O ícone catchall `Iterator` é exibido quando um ícone adequado para o iterador não é encontrado pela lógica que produz planos de execução gráfica. O ícone catchall não indica necessariamente uma condição de erro. Há três ícones catchall: azul (para iteradores), laranja (para cursores) e verde (para construções de linguagem do [!INCLUDE[tsql](../includes/tsql-md.md)] ).|  
|![Ícone do operador Bookmark lookup](../../2014/database-engine/media/bookmark-lookup-32x.gif "Ícone do operador Bookmark lookup")|`Key Lookup`|O `Key Lookup` operador é uma pesquisa de indicador em uma tabela com um índice clusterizado. A `Argument` coluna contém o nome do índice clusterizado e a chave de clustering usada para pesquisar a linha no índice clusterizado. `Key Lookup`é sempre acompanhado por um `Nested Loops` operador. Se a cláusula WITH PREFETCH aparecer na `Argument` coluna, o processador de consultas determinou que é ideal usar a pré-busca assíncrona (Read-Ahead) ao pesquisar indicadores no índice clusterizado.<br /><br /> O uso de um `Key Lookup` operador em um plano de consulta indica que a consulta pode se beneficiar do ajuste de desempenho. Por exemplo, o desempenho da consulta pode ser melhorado adicionando-se um índice de cobertura.|  
|![Ícone do operador de cursor Keyset](../../2014/database-engine/media/keyset-32x.gif "Ícone do operador de cursor Keyset")|`Keyset`|O operador `Keyset` usa um cursor que pode visualizar atualizações, mas não inserções feitas por outros.|  
|![Ícone do elemento de linguagem catchall](../../2014/database-engine/media/language-construct-catch-all.gif "Ícone do elemento de linguagem catchall")|`Language Element`|O ícone catchall `Language Element` é exibido quando um ícone adequado para o iterador não é encontrado pela lógica que produz planos de execução gráfica. O ícone catchall não indica necessariamente uma condição de erro. Há três ícones catchall: azul (para iteradores), laranja (para cursores) e verde (para construções de linguagem do [!INCLUDE[tsql](../includes/tsql-md.md)] ).|  
|![Ícone do operador Spool](../../2014/database-engine/media/spool-32x.gif "Ícone do operador Spool")|**Lazy Spool**|O operador lógico de **spool lento** armazena cada linha de sua entrada em um objeto temporário oculto armazenado no `tempdb` banco de dados. Se o operador for rebobinar (por exemplo, por `Nested Loops` um operador), mas nenhuma reassociação for necessária, os dados em spool serão usados em vez de examinar novamente a entrada. Se a reassociação for necessária, os dados em spool serão descartados e o objeto de spool será recriado por meio do novo exame da entrada (religação). O operador **Lazy Spool** cria seu arquivo de spool de maneira “lenta”, ou seja, sempre que o operador pai do spool solicita uma linha, o operador do spool obtém uma linha de seu operador de entrada e a armazena no spool, em vez de consumir todas as linhas de uma vez. O Lazy Spool é um operador lógico.|  
|Nenhum|`Left Anti Semi Join`|O operador `Left Anti Semi Join` retorna cada linha da primeira entrada (parte superior) quando não existe uma linha correspondente na segunda entrada (parte inferior). Se nenhum predicado de junção `Argument` existir na coluna, cada linha será uma linha correspondente. `Left Anti Semi Join` é um operador lógico.|  
|Nenhum|`Left Outer Join`|O operador `Left Outer Join` retorna cada linha que satisfaz a junção da primeira entrada (parte superior) com a segunda entrada (parte inferior). Ele também retorna linhas da primeira entrada que não teve linhas correspondentes na segunda entrada. As linhas não correspondentes na segunda entrada são retornadas como valores nulos. Se nenhum predicado de junção `Argument` existir na coluna, cada linha será uma linha correspondente. `Left Outer Join` é um operador lógico.|  
|Nenhum|`Left Semi Join`|O operador `Left Semi Join` retorna cada linha da primeira entrada (parte superior) quando existe uma linha correspondente na segunda entrada (parte inferior). Se nenhum predicado de junção `Argument` existir na coluna, cada linha será uma linha correspondente. `Left Semi Join` é um operador lógico.|  
|![Ícone do operador Log row scan](../../2014/database-engine/media/log-row-scan-32x.gif "Ícone do operador Log row scan")|`Log Row Scan`|O operador `Log Row Scan` examina o log de transações. `Log Row Scan` é um operador lógico e físico.|  
|![Ícone do operador Merge interval](../../2014/database-engine/media/merge-interval-32x.gif "Ícone do operador Merge interval")|`Merge Interval`|O operador `Merge Interval` mescla vários intervalos (com sobreposição potencial) para produzir intervalos mínimo, não sobrepostos, usados para buscar entradas de índice. Esse operador geralmente aparece acima de um ou `Compute Scalar` mais operadores `Constant Scan` sobre operadores, que constroem os intervalos (representados como colunas em uma linha) que esse operador mescla. `Merge Interval` é um operador lógico e físico.|  
|![Ícone do operador Merge join](../../2014/database-engine/media/merge-join-32x.gif "Ícone do operador Merge join")|**Junção de Mesclagem**|O operador **Merge Join** executa a inner join, left outer join, left semi join, left anti semi join, right outer join, right semi join, right anti semi join e operações lógicas de união.<br /><br /> Na `Argument` coluna, o operador de **junção de mesclagem** contém um predicado Merge:() se a operação estiver executando uma junção um-para-muitos ou um predicado muitos para muitos:() de mesclagem se a operação estiver executando uma junção muitos para muitos. A `Argument` coluna também inclui uma lista separada por vírgulas de colunas usadas para executar a operação. O operador **Merge Join** requer duas entradas classificadas em suas respectivas colunas, possivelmente inserindo operações de classificação explícitas no plano de consulta. A junção de mesclagem é particularmente eficaz se não for exigida uma classificação explícita, por exemplo, se houver um índice da árvore B adequado no banco de dados, ou se a ordem de classificação puder ser explorada para diversas operações, como uma junção de mesclagem e um agrupamento com acúmulo. **Merge Join** é um operador físico.|  
|![Ícone do operador Nested loops](../../2014/database-engine/media/nested-loops-32x.gif "Ícone do operador Nested loops")|`Nested Loops`|O operador `Nested Loops` executa operações lógicas de junção interna, junção externa esquerda, left semi join e left anti semi join. As junções de loops aninhados executam uma pesquisa na tabela interna para cada linha da tabela externa, normalmente usando um índice. O processador de consultas decide, com base em custos previstos, se classificará a entrada externa para aprimorar a localidade das pesquisas no índice da entrada interna. Todas as linhas que satisfazem o predicado ( `Argument` opcional) na coluna são retornadas conforme aplicável, com base na operação lógica que está sendo executada. `Nested Loops` é um operador físico.|  
|![Ícone do operador Nonclustered index delete](../../2014/database-engine/media/nonclust-index-delete-32x.gif "Ícone do operador Nonclustered index delete")|`Nonclustered Index Delete`|O `Nonclustered Index Delete` operador exclui linhas de entrada do índice não clusterizado especificado na `Argument` coluna. `Nonclustered Index Delete` é um operador físico.|  
|![Ícone do operador Nonclustered index insert](../../2014/database-engine/media/nonclust-index-insert-32x.gif "Ícone do operador Nonclustered index insert")|`Index Insert`|O `Index Insert` operador insere linhas de sua entrada no índice não clusterizado especificado na `Argument` coluna. A coluna `Argument` também contém um predicado SET:(), que indica o valor para o qual cada coluna está definida. `Index Insert` é um operador físico.|  
|![Ícone do operador Nonclustered index scan](../../2014/database-engine/media/nonclustered-index-scan-32x.gif "Ícone do operador Nonclustered index scan")|`Index Scan`|O `Index Scan` operador recupera todas as linhas do índice não clusterizado especificado na `Argument` coluna. Se um predicado opcional WHERE:() aparecer `Argument` na coluna, somente as linhas que atenderem ao predicado serão retornadas. `Index Scan` é um operador lógico e físico.|  
|![Ícone do operador Nonclustered index seek](../../2014/database-engine/media/index-seek-32x.gif "Ícone do operador Nonclustered index seek")|`Index Seek`|O operador `Index Seek` usa a capacidade de busca de índices para recuperar linhas de um índice não clusterizado. A `Argument` coluna contém o nome do índice não clusterizado que está sendo usado. Também contém o predicado SEEK:(). O mecanismo de armazenamento usa o índice para processar somente as linhas que atendem ao predicado SEEK:(). Ele pode incluir opcionalmente um predicado WHERE:(), que o mecanismo de armazenamento avaliará em relação a todas as linhas que atenderem ao predicado SEEK:() (não usa os índices para fazer isso). Se a `Argument` coluna contiver a cláusula ordenada, o processador de consultas determinou que as linhas devem ser retornadas na ordem em que o índice não clusterizado as classificou. Se a cláusula ORDERED não estiver presente, o mecanismo de armazenamento pesquisará o índice no modo ideal (o que não garante que a saída será classificada). Permitir que a saída retenha sua ordenação pode ser menos eficiente que produzir saída não classificada. `Index Seek` é um operador lógico e físico.|  
|![Ícone do operador Nonclustered index spool](../../2014/database-engine/media/index-spool-32x.gif "Ícone do operador Nonclustered index spool")|**Index Spool**|O operador físico do **buffer de índice** contém um predicado `Argument` Seek:() na coluna. O operador **index spool** examina suas linhas de entrada, colocando uma cópia de cada linha em um arquivo de spool oculto (armazenado `tempdb` no banco de dados e existente somente pelo tempo de vida da consulta) e cria um índice não clusterizado nas linhas. Isto permite que você use o recurso de busca de índices para produzir somente as linhas que correspondem ao predicado SEEK: (). Se o operador for rebobinar (por exemplo, por `Nested Loops` um operador), mas nenhuma reassociação for necessária, os dados em spool serão usados em vez de examinar novamente a entrada.|  
|![Ícone do operador Nonclustered index update](../../2014/database-engine/media/nonclust-index-update-32x.gif "Ícone do operador Nonclustered index update")|`Nonclustered Index Update`|O `Nonclustered Index Update` operador físico atualiza as linhas de sua entrada no índice não clusterizado especificado na `Argument` coluna. Se um predicado SET:() estiver presente, cada coluna atualizada será definida com esse valor. `Nonclustered Index Update` é um operador físico.|  
|![Ícone do operador Online index insert](../../2014/database-engine/media/online-index-32x.gif "Ícone do operador Online index insert")|**Online Index Insert**|O operador físico **Online Index Insert** indica que uma operação de criação, alteração ou remoção de índice é executada online. Ou seja, os dados da tabela subjacente permanecem disponíveis para usuários durante a operação de índice.|  
|Nenhum|`Parallelism`|O `Parallelism` operador executa as operações lógicas de distribuir fluxos, coletar fluxos e reparticionar fluxos. As `Argument` colunas podem conter um predicado:() de colunas de partição com uma lista separada por vírgulas das colunas que estão sendo particionadas. As `Argument` colunas também podem conter um predicado order by:(), listando as colunas para preservar a ordem de classificação durante o particionamento. `Parallelism` é um operador físico.<br /><br /> Observação: se uma consulta tiver sido compilada como uma consulta paralela, mas em tempo de execução ela for executada como uma consulta serial, a saída do plano de execução gerada por SET STATISTICs XML ou usando a opção [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] **include real** time plan `RunTimeInformation` no não conterá o elemento para o `Parallelism` operador. Na saída do perfil definir estatísticas, as contagens de linhas reais e o número real de execução exibirão zeros `Parallelism` para o operador. Quando qualquer condição ocorre, isso significa que o `Parallelism` operador só foi usado durante a compilação da consulta e não no plano de consulta de tempo de execução. Observe que às vezes os planos de consulta paralelos serão executados em série, se houver uma carga simultânea grande no servidor.|  
|![Ícone do operador Parameter table scan](../../2014/database-engine/media/parameter-table-scan-32x.gif "Ícone do operador Parameter table scan")|`Parameter Table Scan`|O operador `Parameter Table Scan` examina uma tabela que está atuando como um parâmetro na consulta atual. Normalmente, isto é usado para consultas INSERT dentro de um procedimento armazenado. `Parameter Table Scan` é um operador lógico e físico.|  
|Nenhum|**Partial Aggregate**|**Agregação parcial** é usada em planos paralelos. Aplica uma função de agregação para tantas linhas de entrada quanto possíveis de forma que gravar em disco (conhecido como "derramamento") não é necessário. `Hash Match`é o único operador físico (iterador) que implementa a agregação de partição. **Agregação parcial** é um operador lógico.|  
|![Ícone do operador de cursor Population query](../../2014/database-engine/media/poulation-query-32x.gif "Ícone do operador de cursor Population query")|`Population Query`|O operador `Population Query` popula a tabela de trabalho de um cursor quando o cursor é aberto.|  
|![Ícone do operador de cursor Refresh query](../../2014/database-engine/media/refresh-query-32x.gif "Ícone do operador de cursor Refresh query")|`Refresh Query`|O operador `Refresh Query` busca dados atuais para linhas do buffer de busca.|  
|![Ícone do operador Remote delete](../../2014/database-engine/media/remote-delete-32x.gif "Ícone do operador Remote delete")|`Remote Delete`|O operador `Remote Delete` exclui as linhas de entrada a partir de um objeto remoto. `Remote Delete` é um operador lógico e físico.|  
|![operador Showplan de busca de índice remoto](../../2014/database-engine/media/remote-index-scan-32x.gif "operador remote index seek showplan")|**Remote Index Scan**|O operador **Remote Index Scan** examina o índice remoto especificado na coluna Argument. **Verificação de Índice Remoto** é um operador lógico e físico.|  
|![operador Showplan de busca de índice remoto](../../2014/database-engine/media/remote-index-seek-32x.gif "operador remote index seek showplan")|**Remote Index Seek**|O operador de **Busca de Índice Remoto** usa a busca de um objeto de índice remoto para recuperar linhas. A `Argument` coluna contém o nome do índice remoto que está sendo usado e o predicado Seek:(). **Busca de Índice Remoto** é um operador lógico e físico.|  
|![Ícone do operador Remote insert](../../2014/database-engine/media/remote-insert-32x.gif "Ícone do operador Remote insert")|**Remote Insert**|O operador **Remote Insert** insere linhas de entrada em um objeto remoto. O**Remote Insert** é um operador lógico e físico.|  
|![Ícone do operador Remote query](../../2014/database-engine/media/remote-query-32x.gif "Ícone do operador Remote query")|`Remote Query`|O operador `Remote Query` submete uma consulta a uma fonte remota. O texto da consulta enviada ao servidor remoto aparece na `Argument` coluna. `Remote Query` é um operador lógico e físico.|  
|![Ícone do operador Remote scan](../../2014/database-engine/media/remote-scan-32x.gif "Ícone do operador Remote scan")|`Remote Scan`|O operador `Remote Scan` examina um objeto remoto. O nome do objeto remoto aparece na `Argument` coluna. `Remote Scan` é um operador lógico e físico.|  
|![Ícone do operador Remote update](../../2014/database-engine/media/remote-update-32x.gif "Ícone do operador Remote update")|`Remote Update`|O operador `Remote Update` atualiza a linha de entrada em um objeto remoto. `Remote Update` é um operador lógico e físico.|  
|![Ícone do operador de paralelismo Repartition streams](../../2014/database-engine/media/parallelism-repartition-stream.gif "Ícone do operador de paralelismo Repartition streams")|**Repartition Streams**|O operador **Reparticionar Fluxos** consome vários fluxos e produz vários fluxos de registros. O conteúdo do registro e o formato não são alterados. Se o otimizador de consulta usar um filtro de bitmap, o número de linhas no fluxo de saída será reduzido. Cada registro de um fluxo de entrada é colocado em um fluxo de saída. Se esse operador for preservador de ordem, todos os fluxos de entrada deverão ser ordenados e mesclados em vários fluxos de saída ordenados. Se a saída for particionada, a `Argument` coluna conterá um predicado:() de colunas de partição e as colunas de particionamento. Se a saída for ordenada, a `Argument` coluna conterá um predicado order by:() e as colunas que estão sendo ordenadas. **Reparticionar Fluxos** atua como um operador lógico. O operador é usado somente em planos de consulta paralelos.|  
|![Ícone do elemento de linguagem Result](../../2014/database-engine/media/result-32x.gif "Ícone do elemento de linguagem Result")|`Result`|O operador `Result` consiste nos dados retornados ao término de um plano de consulta. Normalmente, é o elemento raiz de um plano de execução. `Result` é um elemento de linguagem.|  
|![Ícone do operador RID lookup](../../2014/database-engine/media/rid-nonclust-locate-32x.gif "Ícone do operador RID lookup")|`RID Lookup`|`RID Lookup` é um indicador de pesquisa em um heap que usa um RID (identificador de linha) fornecido. A `Argument` coluna contém o rótulo de indicador usado para pesquisar a linha na tabela e o nome da tabela na qual a linha é pesquisada. `RID Lookup` sempre é acompanhado por NESTED LOOP JOIN. `RID Lookup` é um operador físico. Para obter mais informações sobre pesquisas de indicador, consulte o artigo sobre[pesquisa de indicadores](https://go.microsoft.com/fwlink/?LinkId=132568)no blog do SQL Server no MSDN.|  
|Nenhum|`Right Anti Semi Join`|O operador `Right Anti Semi Join` efetua a saída de cada linha a partir da segunda (inferior) entrada quando não existe uma linha correspondente na primeira (superior) entrada. Uma linha correspondente é definida como uma linha que satisfaz o predicado na `Argument` coluna (se nenhum predicado existir, cada linha será uma linha correspondente). `Right Anti Semi Join` é um operador lógico.|  
|Nenhum|`Right Outer Join`|O operador `Right Outer Join` retorna cada linha que satisfaz a junção da segunda entrada (parte inferior) associada a cada linha correspondente da primeira entrada (parte superior). Ele também retorna linhas da segunda entrada que não tiveram linhas correspondentes na primeira entrada, unidas com NULL. Se nenhum predicado de junção `Argument` existir na coluna, cada linha será uma linha correspondente. `Right Outer Join` é um operador lógico.|  
|Nenhum|`Right Semi Join`|O operador `Right Semi Join` retornará todas as linha da segunda entrada (inferior) quando existir uma linha correspondente na primeira entrada (superior). Se nenhum predicado de junção `Argument` existir na coluna, cada linha será uma linha correspondente. `Right Semi Join` é um operador lógico.|  
|![Ícone do operador Row count spool](../../2014/database-engine/media/remote-count-spool-32x.gif "Ícone do operador Row count spool")|**Row Count Spool**|O operador **Row Count Spool** examina a entrada, contando quantas linhas estão presentes e retornando o mesmo número de linhas sem qualquer dado nelas. Esse operador é usado quando é importante a verificação da existência de linhas, em vez dos dados contidos nas linhas. Por exemplo, se um `Nested Loops` operador executar uma operação semijunção à esquerda e o predicado de junção se aplicar à entrada interna, um spool de contagem de linhas poderá ser colocado na parte `Nested Loops` superior da entrada interna do operador. Em seguida `Nested Loops` , o operador pode determinar quantas linhas são geradas pelo spool de contagem de linhas (porque os dados reais do lado interno não são necessários) para determinar se a linha externa deve ser retornada. O**Row Count Spool** é um operador físico.|  
|![Ícone do operador Segment](../../2014/database-engine/media/segment-32x.gif "Ícone do operador Segment")|**Segment**|**Segment** é um operador lógico e físico. Divide a entrada definida em segmentos baseado no valor de uma ou mais colunas. Essas colunas são mostradas como argumentos no operador **Segment** . O operador produz então um segmento por vez.|  
|Nenhum|`Segment Repartition`|Às vezes, em um plano de consulta paralelo, há regiões conceituais de iteradores. Todos os iteradores dentro de tal região podem ser executados por threads paralelos. As próprias regiões devem ser executadas em série. Alguns dos iteradores `Parallelism` em uma região individual são chamados `Branch Repartition`. O iterador `Parallelism` no limite dessas duas regiões é chamado `Segment Repartition`. `Branch Repartition` e `Segment Repartition` são operadores lógicos.|  
|![Ícone do operador Sequence](../../2014/database-engine/media/sequence-32x.gif "Ícone do operador Sequence")|`Sequence`|O operador `Sequence` conduz amplos planos de atualização. Em termos funcionais, ele executa cada entrada em sequência (da parte superior até a inferior). Cada entrada normalmente é uma atualização de um objeto diferente. Ele retorna somente as linhas que vêm de sua última entrada (parte inferior). `Sequence` é um operador lógico e físico.|  
|![Ícone do operador Sequence project](../../2014/database-engine/media/sequence-project-32x.gif "Ícone do operador Sequence project")|`Sequence Project`|O operador `Sequence Project` adiciona colunas para executar computações sobre um conjunto ordenado. Divide a entrada definida em segmentos baseado no valor de uma ou mais colunas. O operador produz então um segmento por vez. Estas colunas são mostradas como argumentos no operador `Sequence Project`. `Sequence Project` é um operador lógico e físico.|  
|![Ícone do operador de cursor Snapshot](../../2014/database-engine/media/snapshot-32x.gif "Ícone do operador de cursor Snapshot")|**Instantâneo**|O operador **Snapshot** cria um cursor que não encontra mudanças feitas pelos outros.|  
|![Ícone do operador Sort](../../2014/database-engine/media/sort-32x.gif "Ícone do operador Sort")|`Sort`|O `Sort` operador classifica todas as linhas de entrada. A `Argument` coluna contém um predicado ordem distinta por:() se as duplicatas forem removidas por essa operação, ou um predicado order by:() com uma lista separada por vírgulas das colunas que estão sendo classificadas. As colunas são prefixadas com o valor ASC se as colunas forem classificadas em ordem crescente, ou o valor DESC se as colunas forem classificadas em ordem decrescente. `Sort` é um operador lógico e físico.|  
|![Ícone do operador Split](../../2014/database-engine/media/split-32x.gif "Ícone do operador Split")|`Split`|O `Split` operador é usado para otimizar o processamento da atualização. Ele divide cada operação de atualização em uma operação de exclusão e inserção. `Split` é um operador lógico e físico.|  
|![Ícone do operador Spool](../../2014/database-engine/media/spool-32x.gif "Ícone do operador Spool")|**Pool**|O operador **spool** salva um resultado de consulta intermediária no `tempdb` banco de dados.|  
|![Ícone do operador Stream aggregate](../../2014/database-engine/media/stream-aggregate-32x.gif "Ícone do operador Stream aggregate")|`Stream Aggregate`|O operador `Stream Aggregate` agrupa linhas por uma ou mais colunas e, em seguida, calcula uma ou mais expressões de agregação retornadas pela consulta. A saída deste operador pode ser referenciada por operadores posteriores na consulta, retornada ao cliente, ou ambos. O operador `Stream Aggregate` requer a entrada de dados ordenada pelas colunas dentro de seus grupos. O otimizador usará um operador `Sort` antes desse operador se os dados ainda não estiverem classificados em função de um operador `Sort` anterior ou devido a uma busca ou análise de índice ordenado. Na instrução SHOWPLAN_ALL ou no plano de execução gráfico no [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)], as colunas no predicado Group by são listadas `Argument` na coluna e as expressões de agregação são listadas na coluna **valores definidos** . `Stream Aggregate` é um operador físico.|  
|![Ícone do operador Switch](../../2014/database-engine/media/switch-32x.gif "Ícone do operador Switch")|**Comutador**|**Switch** é um tipo especial de iterador de concatenação que tem *n* entradas. Uma expressão é associada a cada operador **Switch** . Dependendo do valor retornado da expressão (entre 0 e *n*-1), **Switch** copia o fluxo de entrada apropriado ao fluxo de saída. Um uso de **Switch** é implementar planos de consulta envolvendo cursores de avanço rápido com determinados operadores, como o operador **TOP** . **Switch** é um operador lógico e físico.|  
|![Ícone do operador Table delete](../../2014/database-engine/media/table-delete-32x.gif "Ícone do operador Table delete")|`Table Delete`|O `Table Delete` operador físico exclui linhas da tabela especificada na `Argument` coluna do plano de execução de consulta.|  
|![Ícone do operador Table insert](../../2014/database-engine/media/table-insert-32x.gif "Ícone do operador Table insert")|`Table Insert`|O `Table Insert` operador insere linhas de sua entrada na tabela especificada na `Argument` coluna do plano de execução de consulta. A coluna `Argument` também contém um predicado SET:(), que indica o valor para o qual cada coluna está definida. Se `Table Insert` não tiver nenhum filho para valores de inserção, então a linha inserida será tirada do próprio operador Insert. `Table Insert` é um operador físico.|  
|![Operador Table merge](../../2014/database-engine/media/table-merge-32x.gif "Operador Table merge")|**Table Merge**|O operador **Table Merge** aplica um fluxo de dados de mesclagem a um heap. O operador exclui, atualiza ou insere linhas na tabela especificada na `Argument` coluna do operador. A operação real executada depende do valor de tempo de execução da coluna de **ação** especificada na `Argument` coluna do operador. **Table Merge** é um operador físico.|  
|![Ícone do operador Table scan](../../2014/database-engine/media/table-scan-32x.gif "Ícone do operador Table scan")|`Table Scan`|O `Table Scan` operador recupera todas as linhas da tabela especificada na `Argument` coluna do plano de execução de consulta. Se um predicado WHERE:() aparecer `Argument` na coluna, somente as linhas que atenderem ao predicado serão retornadas. `Table Scan` é um operador lógico e físico.|  
|![Ícone do operador Table spool](../../2014/database-engine/media/table-spool-32x.gif "Ícone do operador Table spool")|**Table Spool**|O operador **Table Spool** examina a entrada e coloca uma cópia de cada linha em uma tabela de spool oculta que é armazenada no banco de dados [tempdb](../relational-databases/databases/tempdb-database.md) e existe durante o tempo de vida da consulta. Se o operador for rebobinar (por exemplo, por `Nested Loops` um operador), mas nenhuma reassociação for necessária, os dados em spool serão usados em vez de examinar novamente a entrada. **Table Spool** é um operador físico.|  
|![Ícone do operador Table update](../../2014/database-engine/media/table-update-32x.gif "Ícone do operador Table update")|`Table Update`|O `Table Update` operador físico atualiza as linhas de entrada na tabela especificada na `Argument` coluna do plano de execução de consulta. O predicado SET: () determina o valor de cada coluna atualizada. Esses valores podem ser consultados na cláusula SET ou em outro lugar dentro desse operador assim como em outro lugar dessa consulta.|  
|![Ícone do operador Table-valued function](../../2014/database-engine/media/table-valued-function-32x.gif "Ícone do operador Table-valued function")|**Função com valor de tabela**|O operador **Table-valued Function** avalia uma função com valor de tabela ( [!INCLUDE[tsql](../includes/tsql-md.md)] ou CLR) e armazena as linhas resultantes no banco de dados [tempdb](../relational-databases/databases/tempdb-database.md) . Quando os iteradores pai solicitam as linhas, a **função com valor de tabela** retorna `tempdb`as linhas de.<br /><br /> As consultas com chamadas às funções com valor de tabela geram planos de consulta com o iterador de **Table-valued Function** . **Table-valued Function** pode ser avaliada com valores de parâmetros diferentes:<br /><br /> O**Leitor de XML da Função com valor de tabela** insere um BLOB XML como parâmetro e processa um conjunto de linhas representando os nós XML na ordem dos documentos XML. Outros parâmetros de entrada podem restringir os nós XML retornados a um subconjunto de documentos XML.<br /><br /> **Leitor de XML da Função com valor de tabela com filtro XPath** é um tipo especial de **Função com valor de tabela do Leitor de XML** que restringe a saída a nós XML que atendem a uma expressão XPath.<br /><br /> <br /><br /> **Table-valued Function** é um operador lógico e físico.|  
|![Ícone do operador Top](../../2014/database-engine/media/top-32x.gif "Ícone do operador Top")|**Início**|O operador **Top** verifica a entrada, retornando só o primeiro número ou porcentagem de linhas especificado, possivelmente com base em uma ordem de classificação. A `Argument` coluna pode conter uma lista das colunas que estão sendo verificadas para as ligações. Em planos de atualização, o operador **Top** é usado para aplicar os limites de contagem de linhas. **Top** é um operador lógico e físico. **Top** é um operador lógico e físico.|  
|Nenhum|**Top N Sort**|A **classificação N superior** é semelhante ao `Sort` iterador, exceto que apenas as primeiras *n* linhas são necessárias, e não todo o conjunto de resultados. Para valores pequenos de *N*, o mecanismo de execução de consultas do [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] tenta executar toda a operação de classificação na memória. Para valores grandes de *N*, o mecanismo de execução de consultas recorre a um método de classificação mais genérico para o qual *N* não é um parâmetro.|  
|![Ícone do operador Extended (UDX)](../../2014/database-engine/media/udx-32x.gif "Ícone do operador Extended (UDX)")|`UDX`|Operadores estendidos (UDX) implementam uma de muitas operações XQuery e XPATH no [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]. Todos os operadores UDX são classificados como operadores lógicos e físicos.<br /><br /> O operador estendido (UDX) `FOR XML` é usado para serializar o conjunto relacional de linhas e insere em representação XML em uma única coluna BLOB, e em uma única linha de saída. É um operador de agregação XML sensível à ordenação.<br /><br /> O operador estendido (UDX) `XML SERIALIZER` é um operador de agregação XML sensível à ordenação. Ele insere linhas que representam nós XML ou escalares de XQuery em ordem de documento XML e produz um XML BLOB serializado em uma única coluna XML em uma única linha de saída.<br /><br /> O operador estendido (UDX) `XML FRAGMENT SERIALIZER`  é um tipo especial de `XML SERIALIZER` que é usado para processar linhas de entrada que representam fragmentos de XML que são inseridos na extensão de modificação de dados de inserção de XQuery.<br /><br /> O operador estendido (UDX) `XQUERY STRING` avalia o valor da cadeia de caracteres XQuery das linhas de entrada que representam nós de XML. É um operador de agregação de cadeia sensível à ordenação. Produz uma linha com colunas que representam o escalar de XQuery que contém o valor de cadeia de caracteres da entrada.<br /><br /> O operador estendido (UDX) `XQUERY LIST DECOMPOSER`é um operador de decomposição de lista de XQuery. Para cada linha de entrada que representa um nó de XML ele produz uma ou mais linhas, cada uma representando o escalar de Xquery, que contém um valor de elemento de lista caso a entrada seja do tipo lista de XSD.<br /><br /> O operador estendido (UDX) `XQUERY DATA` avalia a função XQuery fn:data() na entrada que representa os nós XML. É um operador de agregação de cadeia sensível à ordenação. Ele produz uma linha com colunas que representam o escalar de XQuery que contém o resultado de **fn:data()**.<br /><br /> O operador estendido (UDX) `XQUERY CONTAINS` avalia a função XQuery fn:contains() na entrada que representa os nós XML. É um operador de agregação de cadeia sensível à ordenação. Ele produz uma linha com colunas que representam o escalar de XQuery que contém o resultado de **fn:contains()**.<br /><br /> Nó XML `UPDATE XML NODE` de atualizações do operador estendido no XQuery substituir a extensão de modificação de dados no método **Modify ()** no tipo XML.|  
|Nenhum|**Union**|O operador **Union** verifica várias entradas, gerando a saída de cada linha examinada e removendo duplicatas. **Union** é um operador lógico.|  
|![Ícone do operador Update (mecanismo de banco de dados)](../../2014/database-engine/media/update-32x.gif "Ícone do operador Update (mecanismo de banco de dados)")|`Update`|O `Update` operador atualiza cada linha de sua entrada no objeto especificado na `Argument` coluna do plano de execução de consulta. `Update` é um operador lógico. O operador físico é `Table Update`, `Index Update` ou `Clustered Index Update`.|  
|![Ícone do elemento de linguagem While](../../2014/database-engine/media/while-32x.gif "Ícone do elemento de linguagem While")|`While`|O operador `While` implementa [!INCLUDE[tsql](../includes/tsql-md.md)] durante o loop. `While` é um elemento de linguagem|  
|![Ícone do operador Table spool](../../2014/database-engine/media/table-spool-32x.gif "Ícone do operador Table spool")|`Window Spool`|O operador `Window Spool` expande cada linha no conjunto de linhas que representa a janela associada a ele. Em uma consulta, a cláusula OVER define a janela em um conjunto de resultados de consulta e uma função de janela, e depois computa um valor para cada linha na janela. `Window Spool` é um operador lógico e físico.|  
  
  
