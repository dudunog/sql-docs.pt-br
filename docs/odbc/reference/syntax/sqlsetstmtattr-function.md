---
description: Função SQLSetStmtAttr
title: Função SQLSetStmtAttr | Microsoft Docs
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLSetStmtAttr
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLSetStmtAttr
helpviewer_keywords:
- SQLSetStmtAttr function [ODBC]
ms.assetid: 7abc5260-733a-48d4-9974-2d1a6a9ea5f6
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 7572a907a1111e1c6aa96a2761e8551d3265b2d6
ms.sourcegitcommit: e700497f962e4c2274df16d9e651059b42ff1a10
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/17/2020
ms.locfileid: "88421090"
---
# <a name="sqlsetstmtattr-function"></a>Função SQLSetStmtAttr
**Conformidade**  
 Versão introduzida: conformidade de padrões do ODBC 3,0: ISO 92  
  
 **Resumo**  
 **SQLSetStmtAttr** define atributos relacionados a uma instrução.  
  
> [!NOTE]
>  Para obter mais informações sobre como o Gerenciador de driver mapeia essa função quando um aplicativo ODBC *3. x* está trabalhando com um driver ODBC *2. x* , consulte [mapeando funções de substituição para compatibilidade com versões anteriores de aplicativos](../../../odbc/reference/develop-app/mapping-replacement-functions-for-backward-compatibility-of-applications.md).  
  
## <a name="syntax"></a>Sintaxe  
  
```cpp  
  
SQLRETURN SQLSetStmtAttr(  
     SQLHSTMT      StatementHandle,  
     SQLINTEGER    Attribute,  
     SQLPOINTER    ValuePtr,  
     SQLINTEGER    StringLength);  
```  
  
## <a name="arguments"></a>Argumentos  
 *StatementHandle*  
 Entrada Identificador de instrução.  
  
 *Atributo*  
 Entrada Opção a ser definida, listada em "Comentários".  
  
 *ValuePtr*  
 Entrada Valor a ser associado ao *atributo*. Dependendo do valor do *atributo*, *ValuePtr* será um dos seguintes:  
  
-   Um identificador de descritor ODBC.  
  
-   Um valor SQLUINTEGER.  
  
-   Um valor de SQLULEN.  
  
-   Um ponteiro para um dos seguintes:  
  
    -   Uma cadeia de caracteres terminada em nulo.  
  
    -   Um buffer binário.  
  
    -   Um valor ou matriz do tipo SQLLEN, SQLULEN ou SQLUSMALLINT.  
  
    -   Um valor definido pelo driver.  
  
 Se o argumento de *atributo* for um valor específico de driver, *ValuePtr* poderá ser um inteiro assinado.  
  
 *StringLength*  
 Entrada Se o *atributo* for um atributo definido pelo ODBC e *ValuePtr* apontar para uma cadeia de caracteres ou um buffer binário, esse argumento deverá ter o comprimento de \* *ValuePtr*. Se o *atributo* for um atributo definido pelo ODBC e *ValuePtr* for um inteiro, *StringLength* será ignorado.  
  
 Se o *atributo* for um atributo definido por Driver, o aplicativo indicará a natureza do atributo para o Gerenciador de driver, definindo o argumento *StringLength* . *StringLength* pode ter os seguintes valores:  
  
-   Se *ValuePtr* for um ponteiro para uma cadeia de caracteres, *StringLength* será o comprimento da cadeia de caracteres ou SQL_NTS.  
  
-   Se *ValuePtr* for um ponteiro para um buffer binário, o aplicativo colocará o resultado da macro SQL_LEN_BINARY_ATTR (*Length*) em *StringLength*. Isso coloca um valor negativo em *StringLength*.  
  
-   Se *ValuePtr* for um ponteiro para um valor diferente de uma cadeia de caracteres ou uma cadeia de caracteres binária, *StringLength* deverá ter o valor SQL_IS_POINTER.  
  
-   Se *ValuePtr* contiver um valor de comprimento fixo, o *StringLength* será SQL_IS_INTEGER ou SQL_IS_UINTEGER, conforme apropriado.  
  
## <a name="returns"></a>Retornos  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR ou SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Diagnósticos  
 Quando **SQLSetStmtAttr** retorna SQL_ERROR ou SQL_SUCCESS_WITH_INFO, um valor SQLSTATE associado pode ser obtido chamando **SQLGetDiagRec** com um *HandleType* de SQL_HANDLE_STMT e um *identificador* de *StatementHandle*. A tabela a seguir lista os valores SQLSTATE normalmente retornados por **SQLSetStmtAttr** e explica cada um no contexto dessa função; a notação "(DM)" precede as descrições de sqlstates retornadas pelo Gerenciador de driver. O código de retorno associado a cada valor SQLSTATE é SQL_ERROR, a menos que indicado o contrário.  
  
|SQLSTATE|Erro|Descrição|  
|--------------|-----------|-----------------|  
|01000|Aviso geral|Mensagem informativa específica do driver. (A função retorna SQL_SUCCESS_WITH_INFO.)|  
|01S02|Valor da opção alterado|O driver não oferecia suporte ao valor especificado em *ValuePtr*, ou o valor especificado em *ValuePtr* era inválido devido a condições de trabalho de implementação, portanto, o driver substituiu um valor semelhante. (**SQLGetStmtAttr** pode ser chamado para determinar o valor substituído temporariamente.) O valor de substituição é válido para o *StatementHandle* até que o cursor seja fechado, ponto em que o atributo de instrução reverte para seu valor anterior. Os atributos de instrução que podem ser alterados são:<br /><br /> SQL_ ATTR_CONCURRENCY SQL_ ATTR_CURSOR_TYPE SQL_ ATTR_KEYSET_SIZE SQL_ ATTR_MAX_LENGTH SQL_ ATTR_MAX_ROWS SQL_ ATTR_QUERY_TIMEOUT SQL_ATTR_ROW_ARRAY_SIZE SQL_ ATTR_SIMULATE_CURSOR<br /><br /> (A função retorna SQL_SUCCESS_WITH_INFO.)|  
|08S01|Falha no link de comunicação|O link de comunicação entre o driver e a fonte de dados ao qual o driver foi conectado falhou antes da função concluir o processamento.|  
|24.000|Estado de cursor inválido|O *atributo* foi SQL_ATTR_CONCURRENCY, SQL_ATTR_CURSOR_TYPE, SQL_ATTR_SIMULATE_CURSOR ou SQL_ATTR_USE_BOOKMARKS e o cursor estava aberto.|  
|HY000|Erro geral|Ocorreu um erro para o qual não havia um SQLSTATE específico e para o qual nenhum SQLSTATE específico de implementação foi definido. A mensagem de erro retornada por **SQLGetDiagRec** no buffer * \* MessageText* descreve o erro e sua causa.|  
|HY001|Erro de alocação de memória|O driver não pôde alocar memória necessária para dar suporte à execução ou à conclusão da função.|  
|HY009|Uso inválido de ponteiro nulo|O argumento de *atributo* identificou um atributo de instrução que exigia um atributo de cadeia de caracteres e o argumento *ValuePtr* era um ponteiro nulo.|  
|HY010|Erro de sequência de função|(DM) uma função de execução assíncrona foi chamada para o identificador de conexão que está associado ao *StatementHandle*. Esta função assíncrona ainda estava em execução quando a função **SQLSetStmtAttr** foi chamada.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**ou **SQLMoreResults** foi chamado para *StatementHandle* e retornou SQL_PARAM_DATA_AVAILABLE. Esta função foi chamada antes de os dados serem recuperados para todos os parâmetros transmitidos.<br /><br /> (DM) uma função de execução assíncrona foi chamada para o *StatementHandle* e ainda estava em execução quando essa função foi chamada.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**ou **SQLSetPos** foi chamado para o *StatementHandle* e retornou SQL_NEED_DATA. Esta função foi chamada antes de os dados serem enviados para todos os parâmetros de dados em execução ou colunas.|  
|HY011|O atributo não pode ser definido agora|O *atributo* foi SQL_ATTR_CONCURRENCY, SQL_ ATTR_CURSOR_TYPE, SQL_ ATTR_SIMULATE_CURSOR ou SQL_ ATTR_USE_BOOKMARKS e a instrução foi preparada.|  
|HY013|Erro de gerenciamento de memória|A chamada de função não pôde ser processada porque os objetos de memória subjacentes não puderam ser acessados, possivelmente devido a condições de memória insuficiente.|  
|HY017|Uso inválido de um identificador de descritor alocado automaticamente|(DM) o argumento de *atributo* foi SQL_ATTR_IMP_ROW_DESC ou SQL_ATTR_IMP_PARAM_DESC.<br /><br /> (DM) o argumento de *atributo* foi SQL_ATTR_APP_ROW_DESC ou SQL_ATTR_APP_PARAM_DESC e o valor em *ValuePtr* era um identificador de descritor implicitamente alocado diferente do identificador originalmente ALOCADO para ARD ou APD.|  
|HY024|Valor de atributo inválido|Dado o valor do *atributo* especificado, um valor inválido foi especificado em *ValuePtr*. (O Gerenciador de driver retorna este SQLSTATE somente para atributos de conexão e instrução que aceitam um conjunto discreto de valores, como SQL_ATTR_ACCESS_MODE ou SQL_ ATTR_ASYNC_ENABLE. Para todos os outros atributos de instrução e conexão, o driver deve verificar o valor especificado em *ValuePtr*.)<br /><br /> O argumento de *atributo* foi SQL_ATTR_APP_ROW_DESC ou SQL_ATTR_APP_PARAM_DESC, e *ValuePtr* era um identificador de descritor explicitamente alocado que não está na mesma conexão que o argumento *StatementHandle* .|  
|HY090|Comprimento de cadeia de caracteres ou buffer inválido|(DM) * \* ValuePtr* é uma cadeia de caracteres e o argumento *StringLength* era menor que 0, mas não foi SQL_NTS.|  
|HY092|Identificador de atributo/opção inválido|(DM) o valor especificado para o *atributo* de argumento não era válido para a versão do ODBC com suporte do driver.<br /><br /> (DM) o valor especificado para o *atributo* de argumento era um atributo somente leitura.|  
|HY117|A conexão foi suspensa devido a um estado de transação desconhecido. Somente funções de desconexão e somente leitura são permitidas.|(DM) para obter mais informações sobre o estado suspenso, consulte [função SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Recurso opcional não implementado|O valor especificado para o *atributo* de argumento era um atributo de instrução ODBC válido para a versão do ODBC com suporte do driver, mas não foi suportado pelo driver.<br /><br /> O argumento de *atributo* foi SQL_ATTR_ASYNC_ENABLE e uma chamada para **SQLGetInfo** com um *infotype* de SQL_ASYNC_MODE retorna SQL_AM_CONNECTION.<br /><br /> O argumento de *atributo* foi SQL_ATTR_ENABLE_AUTO_IPD e o valor do atributo de conexão SQL_ATTR_AUTO_IPD foi SQL_FALSE.|  
|HYT01|Tempo limite de conexão expirado|O período de tempo limite de conexão expirou antes que a fonte de dados respondeu à solicitação. O período de tempo limite de conexão é definido por meio de **SQLSetConnectAttr**, SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|O driver não oferece suporte a essa função|(DM) o driver associado ao *StatementHandle* não oferece suporte à função.|  
|S1118|O driver não oferece suporte à notificação assíncrona|Se chamar **SQLSetStmtAttr** para definir SQL_ATTR_ASYNC_STMT_EVENT; o driver não dá suporte à notificação assíncrona.|  
  
## <a name="comments"></a>Comentários  
 Os atributos de instrução para uma instrução permanecem em vigor até que sejam alterados por outra chamada para **SQLSetStmtAttr** ou até que a instrução seja descartada chamando **SQLFreeHandle**. Chamar **SQLFreeStmt** com a opção SQL_CLOSE, SQL_UNBIND ou SQL_RESET_PARAMS não redefine os atributos de instrução.  
  
 Alguns atributos de instrução dão suporte à substituição de um valor semelhante se a fonte de dados não oferecer suporte ao valor especificado em *ValuePtr*. Nesses casos, o driver retorna SQL_SUCCESS_WITH_INFO e SQLSTATE 01S02 (valor da opção alterado). Por exemplo, se o *atributo* for SQL_ATTR_CONCURRENCY e *ValuePtr* for SQL_CONCUR_ROWVER e se a fonte de dados não oferecer suporte a isso, o driver substituirá SQL_CONCUR_VALUES e retornará SQL_SUCCESS_WITH_INFO. Para determinar o valor substituído, um aplicativo chama **SQLGetStmtAttr**.  
  
 O formato do conjunto de informações com *ValuePtr* depende do *atributo*especificado. **SQLSetStmtAttr** aceita informações de atributo em um dos dois formatos diferentes: uma cadeia de caracteres ou um valor inteiro. O formato de cada um é observado na descrição do atributo. Esse formato se aplica às informações retornadas para cada atributo em **SQLGetStmtAttr**. As cadeias de caracteres apontadas pelo argumento *ValuePtr* de **SQLSetStmtAttr** têm um comprimento de *StringLength*.  
  
> [!NOTE]
>  A capacidade de definir atributos de instrução no nível de conexão chamando **SQLSetConnectAttr** foi preterida no ODBC *3. x*. Os aplicativos ODBC *3. x* nunca devem definir atributos de instrução no nível de conexão. Os atributos de instrução ODBC *3. x* não podem ser definidos no nível de conexão, com exceção dos atributos SQL_ATTR_METADATA_ID e SQL_ATTR_ASYNC_ENABLE, que são atributos de conexão e de instrução, e podem ser definidos no nível de conexão ou no nível de instrução.  
> 
> [!NOTE]
>  Os drivers ODBC *3. x* precisam dar suporte apenas a essa funcionalidade se eles devem funcionar com aplicativos ODBC *2. x* que definem as opções de instrução ODBC *2. x* no nível de conexão. Para obter mais informações, consulte "Configurando opções de instrução no nível de conexão" em [mapeamento de SQLSetConnectOption](../../../odbc/reference/appendixes/sqlsetconnectoption-mapping.md) no apêndice G: diretrizes de driver para compatibilidade com versões anteriores.  
  
## <a name="statement-attributes-that-set-descriptor-fields"></a>Atributos de instrução que definem campos de descritor  
 Muitos atributos de instrução correspondem a um campo de cabeçalho de um descritor. Definir esses atributos na verdade resulta na configuração dos campos de descritor. Definir campos por uma chamada para **SQLSetStmtAttr** em vez de **SQLSetDescField** tem a vantagem de que um identificador de descritor não precisa ser obtido para a chamada de função.  
  
> [!CAUTION]  
>  Chamar **SQLSetStmtAttr** para uma instrução pode afetar outras instruções. Isso ocorre quando o APD ou o ARD associado à instrução é explicitamente alocado e também está associado a outras instruções. Como **SQLSetStmtAttr** modifica o APD ou o ARD, as modificações se aplicam a todas as instruções com as quais este descritor está associado. Se esse não for o comportamento necessário, o aplicativo deverá dissociar esse descritor das outras instruções (chamando **SQLSetStmtAttr** para definir o SQL_ATTR_APP_ROW_DESC ou SQL_ATTR_APP_PARAM_DESC campo como um identificador de descritor diferente) antes de chamar **SQLSetStmtAttr** novamente.  
  
 Quando um campo de descritor é definido como resultado do atributo de instrução correspondente que está sendo definido, o campo é definido somente para os descritores aplicáveis que estão associados atualmente à instrução identificada pelo argumento *StatementHandle* , e a configuração de atributo não afeta nenhum descritor que possa ser associado a essa instrução no futuro. Quando um campo de descritor que também é um atributo de instrução é definido por uma chamada para **SQLSetDescField**, o atributo de instrução correspondente é definido. Se um descritor explicitamente alocado for dissociado de uma instrução, um atributo de instrução que corresponde a um campo de cabeçalho será revertido para o valor do campo no descritor implicitamente alocado.  
  
 Quando uma instrução é alocada (consulte [SQLAllocHandle](../../../odbc/reference/syntax/sqlallochandle-function.md)), quatro identificadores de descritor são automaticamente alocados e associados à instrução. Identificadores de descritor explicitamente alocados podem ser associados à instrução chamando **SQLAllocHandle** com um *fHandleType* de SQL_HANDLE_DESC para alocar um identificador de descritor e, em seguida, chamar **SQLSetStmtAttr** para associar o identificador de descritor à instrução.  
  
 Os atributos de instrução na tabela a seguir correspondem aos campos de cabeçalho do descritor.  
  
|Atributo de instrução|Campo de cabeçalho|Crescente.|  
|-------------------------|------------------|-----------|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|APD|  
|SQL_ATTR_PARAM_BIND_TYPE|SQL_DESC_BIND_TYPE|APD|  
|SQL_ATTR_PARAM_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|APD|  
|SQL_ATTR_PARAM_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IPD|  
|SQL_ATTR_PARAMS_PROCESSED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IPD|  
|SQL_ATTR_PARAMSET_SIZE|SQL_DESC_ARRAY_SIZE|APD|  
|SQL_ATTR_ROW_ARRAY_SIZE|SQL_DESC_ARRAY_SIZE|ARD|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|ARD|  
|SQL_ATTR_ROW_BIND_TYPE|SQL_DESC_BIND_TYPE|ARD|  
|SQL_ATTR_ROW_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|ARD|  
|SQL_ATTR_ROW_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IRD|  
|SQL_ATTR_ROWS_FETCHED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IRD|  
  
## <a name="statement-attributes"></a>Atributos de instrução  
 Os atributos definidos no momento e a versão do ODBC na qual eles foram introduzidos são mostrados na tabela a seguir; Espera-se que mais atributos sejam definidos pelos drivers para tirar proveito de diferentes fontes de dados. Um intervalo de atributos é reservado pelo ODBC; os desenvolvedores de driver devem reservar valores para seu próprio uso específico de driver de um grupo aberto. Para obter mais informações, consulte [tipos de dados específicos do driver, tipos de descritores, tipos de informações, tipos de diagnóstico e atributos](../../../odbc/reference/develop-app/driver-specific-data-types-descriptor-information-diagnostic.md).  
  
|Atributo|Conteúdo do *ValuePtr*|  
|---------------|-------------------------|  
|SQL_ATTR_APP_PARAM_DESC (ODBC 3,0)|O identificador para o APD para chamadas subsequentes para **SQLExecute** e **SQLExecDirect** no identificador de instrução. O valor inicial desse atributo é o descritor implicitamente alocado quando a instrução foi alocada inicialmente. Se o valor desse atributo for definido como SQL_NULL_DESC ou o identificador originalmente alocado para o descritor, um identificador APD explicitamente alocado que foi anteriormente associado ao identificador de instrução será dissociado dele e o identificador de instrução reverterá para o identificador APD implicitamente alocado.<br /><br /> Este atributo não pode ser definido como um identificador de descritor que foi alocado implicitamente para outra instrução ou para outro identificador de descritor que foi implicitamente definido na mesma instrução; identificadores de descritor alocados implicitamente não podem ser associados a mais de uma instrução ou identificador de descritor.|  
|SQL_ATTR_APP_ROW_DESC (ODBC 3,0)|O identificador para o ARD para buscas subsequentes no identificador da instrução. O valor inicial desse atributo é o descritor implicitamente alocado quando a instrução foi alocada inicialmente. Se o valor desse atributo for definido como SQL_NULL_DESC ou o identificador originalmente alocado para o descritor, um identificador ARD explicitamente alocado que foi anteriormente associado ao identificador de instrução será dissociado dele e o identificador de instrução reverterá para o identificador ARD implicitamente alocado.<br /><br /> Este atributo não pode ser definido como um identificador de descritor que foi alocado implicitamente para outra instrução ou para outro identificador de descritor que foi implicitamente definido na mesma instrução; identificadores de descritor alocados implicitamente não podem ser associados a mais de uma instrução ou identificador de descritor.|  
|SQL_ATTR_ASYNC_ENABLE (ODBC 1,0)|Um valor SQLULEN que especifica se uma função chamada com a instrução especificada é executada de forma assíncrona:<br /><br /> SQL_ASYNC_ENABLE_OFF = desabilite o suporte à execução assíncrona de nível de instrução (o padrão).<br /><br /> SQL_ASYNC_ENABLE_ON = habilitar o suporte à execução assíncrona em nível de instrução.<br /><br /> Para obter mais informações, consulte [execução assíncrona (método de sondagem)](../../../odbc/reference/develop-app/asynchronous-execution-polling-method.md).<br /><br /> Para drivers com suporte de execução assíncrona em nível de instrução, o atributo de instrução SQL_ATTR_ASYNC_ENABLE é somente leitura. Seu valor é o mesmo que o valor do atributo de nível de conexão com o mesmo nome no momento em que o identificador de instrução foi alocado.<br /><br /> Chamar **SQLSetStmtAttr** para definir SQL_ATTR_ASYNC_ENABLE quando o SQL_ASYNC_MODE *infotype* retorna SQL_AM_CONNECTION retorna SQLSTATE HYC00 (recurso opcional não implementado). Para obter mais informações, consulte a [função SQLSetConnectAttr](../../../odbc/reference/syntax/sqlsetconnectattr-function.md) para obter mais informações.|  
|SQL_ATTR_ASYNC_STMT_EVENT (ODBC 3,8)|Um valor SQLPOINTER que é um manipulador de eventos.<br /><br /> A notificação de conclusão de funções assíncronas é habilitada chamando **SQLSetStmtAttr** para definir o atributo **SQL_ATTR_ASYNC_STMT_EVENT** e especificar o identificador de evento.|  
|SQL_ATTR_ASYNC_STMT_PCALLBACK (ODBC 3,8)|Um SQLPOINTER para a função de retorno de chamada assíncrona.<br /><br /> Somente o Gerenciador de driver pode chamar a função **SQLSetStmtAttr** de um driver com esse atributo.|  
|SQL_ATTR_ASYNC_STMT_PCONTEXT (ODBC 3,8)|Um SQLPOINTER para a estrutura de contexto<br /><br /> Somente o Gerenciador de driver pode chamar a função **SQLSetStmtAttr** de um driver com esse atributo.|  
|SQL_ATTR_CONCURRENCY (ODBC 2,0)|Um valor de SQLULEN que especifica a simultaneidade do cursor:<br /><br /> SQL_CONCUR_READ_ONLY = o cursor é somente leitura. Nenhuma atualização é permitida.<br /><br /> SQL_CONCUR_LOCK = o cursor usa o nível mais baixo de bloqueio suficiente para garantir que a linha possa ser atualizada.<br /><br /> SQL_CONCUR_ROWVER = cursor usa controle de simultaneidade otimista, comparando versões de linha, como SQLBase ROWID ou Sybase TIMESTAMP.<br /><br /> SQL_CONCUR_VALUES = cursor usa controle de simultaneidade otimista, comparando valores.<br /><br /> O valor padrão para SQL_ATTR_CONCURRENCY é SQL_CONCUR_READ_ONLY.<br /><br /> Este atributo não pode ser especificado para um cursor aberto. Para obter mais informações, consulte [tipos de simultaneidade](../../../odbc/reference/develop-app/concurrency-types.md).<br /><br /> Se o *atributo* SQL_ATTR_CURSOR_TYPE for alterado para um tipo que não oferece suporte ao valor atual de SQL_ATTR_CONCURRENCY, o valor de SQL_ATTR_CONCURRENCY será alterado no momento da execução e um aviso será emitido quando **SQLExecDirect** ou **SQLPrepare** for chamado.<br /><br /> Se o driver oferecer suporte à instrução **SELECT for Update** e tal instrução for executada enquanto o valor de SQL_ATTR_CONCURRENCY for definido como SQL_CONCUR_READ_ONLY, um erro será retornado. Se o valor de SQL_ATTR_CONCURRENCY for alterado para um valor que o driver dá suporte para algum valor de SQL_ATTR_CURSOR_TYPE mas não para o valor atual de SQL_ATTR_CURSOR_TYPE, o valor de SQL_ATTR_CURSOR_TYPE será alterado em tempo de execução e SQLSTATE 01S02 (valor de opção alterado) será emitido quando **SQLExecDirect** ou **SQLPrepare** for chamado.<br /><br /> Se a simultaneidade especificada não for suportada pela fonte de dados, o driver substituirá uma simultaneidade diferente e retornará SQLSTATE 01S02 (valor da opção alterado). Por SQL_CONCUR_VALUES, o driver substitui SQL_CONCUR_ROWVER e vice-versa. Por SQL_CONCUR_LOCK, o driver substitui, na ordem, SQL_CONCUR_ROWVER ou SQL_CONCUR_VALUES. A validade do valor substituído não é verificada até o tempo de execução.<br /><br /> Para obter mais informações sobre a relação entre SQL_ATTR_CONCURRENCY e os outros atributos de cursor, consulte [características do cursor e tipo de cursor](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_SCROLLABLE (ODBC 3,0)|Um valor de SQLULEN que especifica o nível de suporte que o aplicativo requer. A definição desse atributo afeta as chamadas subsequentes para **SQLExecDirect** e **SQLExecute**.<br /><br /> SQL_NONSCROLLABLE = cursores roláveis não são necessários no identificador de instrução. Se o aplicativo chamar **SQLFetchScroll** nesse identificador, o único valor válido de *FetchOrientation* será SQL_FETCH_NEXT. Esse é o padrão.<br /><br /> SQL_SCROLLABLE = cursores roláveis são necessários no identificador da instrução. Ao chamar **SQLFetchScroll**, o aplicativo pode especificar qualquer valor válido de *FetchOrientation*, alcançando o posicionamento do cursor em modos diferentes do modo sequencial.<br /><br /> Para obter mais informações sobre cursores roláveis, consulte [cursores roláveis](../../../odbc/reference/develop-app/scrollable-cursors.md). Para obter mais informações sobre a relação entre SQL_ATTR_CURSOR_SCROLLABLE e os outros atributos de cursor, consulte [características do cursor e tipo de cursor](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md)|  
|SQL_ATTR_CURSOR_SENSITIVITY (ODBC 3,0)|Um valor SQLULEN que especifica se os cursores no identificador de instrução tornam visíveis as alterações feitas em um conjunto de resultados por outro cursor. A definição desse atributo afeta as chamadas subsequentes para **SQLExecDirect** e **SQLExecute**. Um aplicativo pode ler de volta o valor desse atributo para obter seu estado inicial ou seu estado como definido mais recentemente pelo aplicativo.<br /><br /> SQL_UNSPECIFIED = ele não especifica qual é o tipo de cursor e se os cursores no identificador de instrução tornam visíveis as alterações feitas em um conjunto de resultados por outro cursor. Os cursores no identificador de instrução podem tornar visíveis nenhuma, algumas ou todas essas alterações. Esse é o padrão.<br /><br /> SQL_INSENSITIVE = todos os cursores no identificador de instrução mostram o conjunto de resultados sem refletir as alterações feitas a ele por qualquer outro cursor. Cursores insensíveis são somente leitura. Isso corresponde a um cursor estático, que tem uma simultaneidade que é somente leitura.<br /><br /> SQL_SENSITIVE = todos os cursores no identificador de instrução tornam visíveis todas as alterações feitas em um conjunto de resultados por outro cursor.<br /><br /> Para obter mais informações sobre a relação entre SQL_ATTR_CURSOR_SENSITIVITY e os outros atributos de cursor, consulte [características do cursor e tipo de cursor](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_TYPE (ODBC 2,0)|Um valor de SQLULEN que especifica o tipo de cursor:<br /><br /> SQL_CURSOR_FORWARD_ONLY = o cursor só rola para frente.<br /><br /> SQL_CURSOR_STATIC = os dados no conjunto de resultados são estáticos.<br /><br /> SQL_CURSOR_KEYSET_DRIVEN = o driver salva e usa as chaves para o número de linhas especificado no atributo de instrução SQL_ATTR_KEYSET_SIZE.<br /><br /> SQL_CURSOR_DYNAMIC = o driver salva e usa apenas as chaves para as linhas no conjunto de linhas.<br /><br /> O valor padrão é SQL_CURSOR_FORWARD_ONLY. Este atributo não pode ser especificado depois que a instrução SQL tiver sido preparada.<br /><br /> Se o tipo de cursor especificado não for suportado pela fonte de dados, o driver substituirá um tipo de cursor diferente e retornará SQLSTATE 01S02 (valor de opção alterado). Para um cursor misto ou dinâmico, o driver substitui, em ordem, um cursor estático ou controlado por conjunto de chaves. Para um cursor controlado por conjunto de chaves, o driver substitui um cursor estático.<br /><br /> Para obter mais informações sobre tipos de cursor rolável, consulte [tipos de cursor rolável](../../../odbc/reference/develop-app/scrollable-cursor-types.md). Para obter mais informações sobre a relação entre SQL_ATTR_CURSOR_TYPE e os outros atributos de cursor, consulte [características do cursor e tipo de cursor](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_ENABLE_AUTO_IPD (ODBC 3,0)|Um valor SQLULEN que especifica se a população automática do IPD é executada:<br /><br /> SQL_TRUE = ativa a população automática do IPD após uma chamada para **SQLPrepare**. SQL_FALSE = desativa a população automática do IPD após uma chamada para **SQLPrepare**. (Um aplicativo ainda pode obter informações de campo de IPD chamando **SQLDescribeParam**, se houver suporte.) O valor padrão do atributo de instrução SQL_ATTR_ENABLE_AUTO_IPD é SQL_FALSE. Para obter mais informações, consulte [população automática do IPD](../../../odbc/reference/develop-app/automatic-population-of-the-ipd.md).|  
|SQL_ATTR_FETCH_BOOKMARK_PTR (ODBC 3,0)|Um SQLLEN \* que aponta para um valor de indicador binário. Quando **SQLFetchScroll** é chamado com *fFetchOrientation* igual a SQL_FETCH_BOOKMARK, o driver pega o valor do indicador desse campo. O padrão desse campo é um ponteiro nulo. Para obter mais informações, consulte [rolando por indicador](../../../odbc/reference/develop-app/scrolling-by-bookmark.md).<br /><br /> O valor apontado por este campo não é usado para as operações excluir por indicador, atualizar por indicador ou buscar por indicador em **SQLBulkOperations**, que usam indicadores em cache em buffers de conjunto de linhas.|  
|SQL_ATTR_IMP_PARAM_DESC (ODBC 3,0)|O identificador para o IPD. O valor desse atributo é o descritor alocado quando a instrução foi alocada inicialmente. O aplicativo não pode definir este atributo.<br /><br /> Esse atributo pode ser recuperado por uma chamada para **SQLGetStmtAttr** , mas não definido por uma chamada para **SQLSetStmtAttr**.|  
|SQL_ATTR_IMP_ROW_DESC (ODBC 3,0)|O identificador para o IRD. O valor desse atributo é o descritor alocado quando a instrução foi alocada inicialmente. O aplicativo não pode definir este atributo.<br /><br /> Esse atributo pode ser recuperado por uma chamada para **SQLGetStmtAttr** , mas não definido por uma chamada para **SQLSetStmtAttr**.|  
|SQL_ATTR_KEYSET_SIZE (ODBC 2,0)|Um SQLULEN que especifica o número de linhas no conjunto de chaves para um cursor controlado por conjunto de chaves. Se o tamanho do conjunto de chaves for 0 (o padrão), o cursor será totalmente controlado por conjunto de chaves. Se o tamanho do conjunto de chaves for maior que 0, o cursor será misto (controlado por conjunto de chaves no conjunto de chaves e dinâmico fora do conjunto de chaves). O tamanho padrão do conjunto de chaves é 0. Para obter mais informações sobre cursores controlados por conjunto de chaves, consulte [cursores controlados](../../../odbc/reference/develop-app/keyset-driven-cursors.md)por conjunto de chaves.<br /><br /> Se o tamanho especificado exceder o tamanho máximo do conjunto de chaves, o driver substituirá esse tamanho e retornará SQLSTATE 01S02 (valor da opção alterado).<br /><br /> **SQLFetch** ou **SQLFetchScroll** retornará um erro se o tamanho do conjunto de chaves for maior que 0 e menor do que o tamanho da Rowset.|  
|SQL_ATTR_MAX_LENGTH (ODBC 1,0)|Um valor de SQLULEN que especifica a quantidade máxima de dados que o driver retorna de um caractere ou coluna binária. Se *ValuePtr* for menor que o comprimento dos dados disponíveis, **SQLFetch** ou **SQLGetData** truncará os dados e retornará SQL_SUCCESS. Se *ValuePtr* for 0 (o padrão), o driver tentará retornar todos os dados disponíveis.<br /><br /> Se o comprimento especificado for menor que a quantidade mínima de dados que a fonte de dados pode retornar ou maior que a quantidade máxima de dados que a fonte de dados pode retornar, o driver substituirá esse valor e retornará SQLSTATE 01S02 (valor de opção alterado).<br /><br /> O valor desse atributo pode ser definido em um cursor aberto; no entanto, a configuração pode não entrar em vigor imediatamente; nesse caso, o driver retornará SQLSTATE 01S02 (valor da opção alterado) e redefinirá o atributo para seu valor original.<br /><br /> Esse atributo destina-se a reduzir o tráfego de rede e deve ter suporte apenas quando a fonte de dados (ao contrário do driver) em um driver de várias camadas pode implementá-lo. Esse mecanismo não deve ser usado por aplicativos para truncar dados; para truncar os dados recebidos, um aplicativo deve especificar o comprimento máximo do buffer no argumento *BufferLength* em **SQLBindCol** ou **SQLGetData**.|  
|SQL_ATTR_MAX_ROWS (ODBC 1,0)|Um valor de SQLULEN correspondente ao número máximo de linhas a serem retornadas ao aplicativo para uma instrução **Select** . Se \* *ValuePtr* for igual a 0 (o padrão), o driver retornará todas as linhas.<br /><br /> Esse atributo destina-se a reduzir o tráfego de rede. Conceitualmente, ele é aplicado quando o conjunto de resultados é criado e limita o conjunto de resultados às primeiras linhas *ValuePtr* . Se o número de linhas no conjunto de resultados for maior que *ValuePtr*, o conjunto de resultados será truncado.<br /><br /> SQL_ATTR_MAX_ROWS se aplica a todos os conjuntos de resultados na *instrução*, incluindo aqueles retornados pelas funções de catálogo. SQL_ATTR_MAX_ROWS estabelece um máximo para o valor da contagem de linhas do cursor.<br /><br /> Um driver não deve emular o comportamento de SQL_ATTR_MAX_ROWS para **SQLFetch** ou **SQLFetchScroll** (se as limitações de tamanho do conjunto de resultados não puderem ser implementadas na fonte de dados) se não for possível garantir que SQL_ATTR_MAX_ROWS serão implementadas corretamente.<br /><br /> Ele é definido por driver se SQL_ATTR_MAX_ROWS se aplica a instruções diferentes de instruções SELECT (como funções de catálogo).<br /><br /> O valor desse atributo pode ser definido em um cursor aberto; no entanto, a configuração pode não entrar em vigor imediatamente; nesse caso, o driver retornará SQLSTATE 01S02 (valor da opção alterado) e redefinirá o atributo para seu valor original.|  
|SQL_ATTR_METADATA_ID (ODBC 3,0)|Um valor SQLULEN que determina como os argumentos de cadeia de caracteres das funções de catálogo são tratados.<br /><br /> Se SQL_TRUE, o argumento de cadeia de caracteres das funções de catálogo será tratado como identificadores. O caso não é significativo. Para cadeias de caracteres não delimitadas, o driver remove espaços à direita e a cadeia de caracteres é dobrada em maiúsculas. Para cadeias de caracteres delimitadas, o driver remove espaços à esquerda ou à direita e usa o que estiver entre os delimitadores literalmente. Se um desses argumentos for definido como um ponteiro NULL, a função retornará SQL_ERROR e SQLSTATE HY009 (uso inválido de ponteiro NULL).<br /><br /> Se SQL_FALSE, os argumentos de cadeia de caracteres das funções de catálogo não serão tratados como identificadores. O caso é significativo. Eles podem conter um padrão de pesquisa de cadeia de caracteres ou não, dependendo do argumento.<br /><br /> O valor padrão é SQL_FALSE.<br /><br /> O argumento *TableName* de **SQLTables**, que usa uma lista de valores, não é afetado por esse atributo.<br /><br /> SQL_ATTR_METADATA_ID também pode ser definido no nível de conexão. (It e SQL_ATTR_ASYNC_ENABLE são os únicos atributos de instrução que também são atributos de conexão.)<br /><br /> Para obter mais informações, consulte [argumentos em funções de catálogo](../../../odbc/reference/develop-app/arguments-in-catalog-functions.md).|  
|SQL_ATTR_NOSCAN (ODBC 1,0)|Um valor SQLULEN que indica se o driver deve verificar as cadeias de caracteres SQL para sequências de escape:<br /><br /> SQL_NOSCAN_OFF = o driver examina as cadeias de caracteres SQL para sequências de escape (o padrão).<br /><br /> SQL_NOSCAN_ON = o driver não examina as cadeias de caracteres SQL para sequências de escape. Em vez disso, o driver envia a instrução diretamente para a fonte de dados.<br /><br /> Para obter mais informações, consulte [sequências de escape no ODBC](../../../odbc/reference/develop-app/escape-sequences-in-odbc.md).|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR (ODBC 3,0)|Um valor SQLULEN * que aponta para um deslocamento adicionado a ponteiros para alterar a associação de parâmetros dinâmicos. Se esse campo for não nulo, o driver desreferenciará o ponteiro, adicionará o valor de referência a cada um dos campos adiados no registro do descritor (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR e SQL_DESC_OCTET_LENGTH_PTR) e usará os novos valores de ponteiro ao associar. Ele é definido como NULL por padrão.<br /><br /> O deslocamento de ligação é sempre adicionado diretamente aos campos SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR e SQL_DESC_OCTET_LENGTH_PTR. Se o deslocamento for alterado para um valor diferente, o novo valor ainda será adicionado diretamente ao valor no campo descritor. O novo deslocamento não é adicionado ao valor do campo mais quaisquer deslocamentos anteriores.<br /><br /> Para obter mais informações, consulte [deslocamentos de associação de parâmetro](../../../odbc/reference/develop-app/parameter-binding-offsets.md).<br /><br /> A definição desse atributo de instrução define o campo SQL_DESC_BIND_OFFSET_PTR no cabeçalho APD.|  
|SQL_ATTR_PARAM_BIND_TYPE (ODBC 3,0)|Um valor SQLULEN que indica a orientação de associação a ser usada para parâmetros dinâmicos.<br /><br /> Esse campo é definido como SQL_PARAM_BIND_BY_COLUMN (o padrão) para selecionar a associação de coluna.<br /><br /> Para selecionar a associação de linha, esse campo é definido como o comprimento da estrutura ou uma instância de um buffer que será associado a um conjunto de parâmetros dinâmicos. Esse comprimento deve incluir espaço para todos os parâmetros associados e qualquer preenchimento da estrutura ou do buffer para garantir que, quando o endereço de um parâmetro associado for incrementado com o comprimento especificado, o resultado apontará para o início do mesmo parâmetro no próximo conjunto de parâmetros. Ao usar o operador *sizeof* no ANSI C, esse comportamento é garantido.<br /><br /> Para obter mais informações, consulte [associando matrizes de parâmetros](../../../odbc/reference/develop-app/binding-arrays-of-parameters.md).<br /><br /> A definição desse atributo de instrução define o SQL_DESC_ BIND_TYPE campo no cabeçalho APD.|  
|SQL_ATTR_PARAM_OPERATION_PTR (ODBC 3,0)|Um \* valor SQLUSMALLINT que aponta para uma matriz de valores SQLUSMALLINT usados para ignorar um parâmetro durante a execução de uma instrução SQL. Cada valor é definido como SQL_PARAM_PROCEED (para o parâmetro a ser executado) ou SQL_PARAM_IGNORE (para que o parâmetro seja ignorado).<br /><br /> Um conjunto de parâmetros pode ser ignorado durante o processamento, definindo o valor de status na matriz apontada por SQL_DESC_ARRAY_STATUS_PTR no APD para SQL_PARAM_IGNORE. Um conjunto de parâmetros será processado se seu valor de status for definido como SQL_PARAM_PROCEED ou se nenhum elemento na matriz estiver definido.<br /><br /> Esse atributo de instrução pode ser definido como um ponteiro NULL; nesse caso, o driver não retorna valores de status de parâmetro. Esse atributo pode ser definido a qualquer momento, mas o novo valor não é usado até a próxima vez que **SQLExecDirect** ou **SQLExecute** seja chamado.<br /><br /> Esse atributo é ignorado quando não há nenhum parâmetro associado.<br /><br /> Para obter mais informações, consulte [usando matrizes de parâmetros](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> A definição desse atributo de instrução define o campo SQL_DESC_ARRAY_STATUS_PTR no cabeçalho APD.|  
|SQL_ATTR_PARAM_STATUS_PTR (ODBC 3,0)|Um \* valor SQLUSMALLINT que aponta para uma matriz de valores de SQLUSMALLINT que contém informações de status para cada linha de valores de parâmetro após uma chamada para **SQLExecute** ou **SQLExecDirect**. Este campo será necessário somente se PARAMSET_SIZE for maior que 1.<br /><br /> Os valores de status podem conter os seguintes valores:<br /><br /> SQL_PARAM_SUCCESS: a instrução SQL foi executada com êxito para este conjunto de parâmetros.<br /><br /> SQL_PARAM_SUCCESS_WITH_INFO: a instrução SQL foi executada com êxito para este conjunto de parâmetros; no entanto, as informações de aviso estão disponíveis na estrutura de dados de diagnóstico.<br /><br /> SQL_PARAM_ERROR: ocorreu um erro ao processar esse conjunto de parâmetros. Informações de erro adicionais estão disponíveis na estrutura de dados de diagnóstico.<br /><br /> SQL_PARAM_UNUSED: esse conjunto de parâmetros não foi usado, possivelmente devido ao fato de que algum conjunto de parâmetros anterior causou um erro que anulava o processamento adicional ou porque SQL_PARAM_IGNORE foi definido para esse conjunto de parâmetros na matriz especificada pelo SQL_ATTR_PARAM_OPERATION_PTR.<br /><br /> SQL_PARAM_DIAG_UNAVAILABLE: o driver trata as matrizes de parâmetros como uma unidade monolítica e, portanto, não gera esse nível de informações de erro.<br /><br /> Esse atributo de instrução pode ser definido como um ponteiro NULL; nesse caso, o driver não retorna valores de status de parâmetro. Esse atributo pode ser definido a qualquer momento, mas o novo valor não é usado até que a próxima vez que **SQLExecute** ou **SQLExecDirect** seja chamada. Observe que a configuração desse atributo pode afetar o comportamento do parâmetro de saída implementado pelo driver.<br /><br /> Para obter mais informações, consulte [usando matrizes de parâmetros](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> A definição desse atributo de instrução define o campo SQL_DESC_ARRAY_STATUS_PTR no cabeçalho IPD.|  
|SQL_ATTR_PARAMS_PROCESSED_PTR (ODBC 3,0)|Um \* campo de registro SQLULEN que aponta para um buffer no qual retornar o número de conjuntos de parâmetros que foram processados, incluindo conjuntos de erros. Nenhum número será retornado se esse for um ponteiro nulo.<br /><br /> A definição desse atributo de instrução define o campo SQL_DESC_ROWS_PROCESSED_PTR no cabeçalho IPD.<br /><br /> Se a chamada para **SQLExecDirect** ou **SQLExecute** que preenche o buffer apontado por esse atributo não retornar SQL_SUCCESS ou SQL_SUCCESS_WITH_INFO, o conteúdo do buffer será indefinido.<br /><br /> Para obter mais informações, consulte [usando matrizes de parâmetros](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).|  
|SQL_ATTR_PARAMSET_SIZE (ODBC 3,0)|Um valor de SQLULEN que especifica o número de valores para cada parâmetro. Se SQL_ATTR_PARAMSET_SIZE for maior que 1, SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR e SQL_DESC_OCTET_LENGTH_PTR do ponto de APD para matrizes. A cardinalidade de cada matriz é igual ao valor desse campo.<br /><br /> Esse atributo é ignorado quando não há nenhum parâmetro associado.<br /><br /> Para obter mais informações, consulte [usando matrizes de parâmetros](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> A definição desse atributo de instrução define o campo SQL_DESC_ARRAY_SIZE no cabeçalho APD.|  
|SQL_ATTR_QUERY_TIMEOUT (ODBC 1,0)|Um valor de SQLULEN correspondente ao número de segundos a aguardar a execução de uma instrução SQL antes de retornar ao aplicativo. Se *ValuePtr* for igual a 0 (padrão), não haverá tempo limite.<br /><br /> Se o tempo limite especificado exceder o tempo limite máximo na fonte de dados ou for menor que o tempo limite mínimo, o **SQLSetStmtAttr** substituirá esse valor e retornará SQLSTATE 01S02 (valor de opção alterado).<br /><br /> Observe que o aplicativo não precisa chamar **SQLCloseCursor** para reutilizar a instrução se uma instrução **Select** esgotou o tempo limite.<br /><br /> O tempo limite da consulta definido neste atributo de instrução é válido nos modos síncrono e assíncrono.|  
|SQL_ATTR_RETRIEVE_DATA (ODBC 2,0)|Um valor de SQLULEN:<br /><br /> SQL_RD_ON = **SQLFetchScroll** e, no ODBC *3. x*, **SQLFetch** recupera dados depois que posiciona o cursor no local especificado. Esse é o padrão.<br /><br /> SQL_RD_OFF = **SQLFetchScroll** e, no ODBC *3. x*, **SQLFetch** não recupera dados depois de posicionar o cursor.<br /><br /> Ao definir SQL_RETRIEVE_DATA como SQL_RD_OFF, um aplicativo pode verificar se existe uma linha ou recuperar um indicador para a linha sem incorrer na sobrecarga de recuperação de linhas. Para obter mais informações, consulte [rolagem e busca de linhas](../../../odbc/reference/develop-app/scrolling-and-fetching-rows-odbc.md).<br /><br /> O valor desse atributo pode ser definido em um cursor aberto; no entanto, a configuração pode não entrar em vigor imediatamente; nesse caso, o driver retornará SQLSTATE 01S02 (valor da opção alterado) e redefinirá o atributo para seu valor original.|  
|SQL_ATTR_ROW_ARRAY_SIZE (ODBC 3,0)|Um valor de SQLULEN que especifica o número de linhas retornadas por cada chamada para **SQLFetch** ou **SQLFetchScroll**. Também é o número de linhas em uma matriz de indicadores usada em uma operação de indicador em massa em **SQLBulkOperations**. O valor padrão é 1.<br /><br /> Se o tamanho do conjunto de linhas especificado exceder o tamanho máximo de conjunto de linhas suportado pela fonte de dados, o driver substituirá esse valor e retornará SQLSTATE 01S02 (valor de opção alterado).<br /><br /> Para obter mais informações, consulte [tamanho do conjunto de linhas](../../../odbc/reference/develop-app/rowset-size.md).<br /><br /> A definição desse atributo de instrução define o campo SQL_DESC_ARRAY_SIZE no cabeçalho ARD.|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR (ODBC 3,0)|Um valor SQLULEN * que aponta para um deslocamento adicionado a ponteiros para alterar a associação de dados de coluna. Se esse campo for não nulo, o driver desreferenciará o ponteiro, adicionará o valor de referência a cada um dos campos adiados no registro do descritor (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR e SQL_DESC_OCTET_LENGTH_PTR) e usará os novos valores de ponteiro ao associar. Ele é definido como NULL por padrão.<br /><br /> A definição desse atributo de instrução define o campo SQL_DESC_BIND_OFFSET_PTR no cabeçalho ARD.|  
|SQL_ATTR_ROW_BIND_TYPE (ODBC 1,0)|Um valor SQLULEN que define a orientação de associação a ser usada quando **SQLFetch** ou **SQLFetchScroll** é chamado na instrução associada. A associação de coluna é selecionada definindo o valor como SQL_BIND_BY_COLUMN. A associação de linha é selecionada definindo o valor como o comprimento de uma estrutura ou uma instância de um buffer no qual as colunas de resultado serão associadas.<br /><br /> Se um comprimento for especificado, ele deverá incluir o espaço para todas as colunas associadas e qualquer preenchimento da estrutura ou do buffer para garantir que, quando o endereço de uma coluna associada for incrementado com o comprimento especificado, o resultado aponte para o início da mesma coluna na próxima linha. Ao usar o operador **sizeof** com estruturas ou uniões em ANSI C, esse comportamento é garantido.<br /><br /> A associação de coluna é a orientação de associação padrão para **SQLFetch** e **SQLFetchScroll**.<br /><br /> Para obter mais informações, consulte [associando colunas para uso com cursores de bloco](../../../odbc/reference/develop-app/binding-columns-for-use-with-block-cursors.md).<br /><br /> A definição desse atributo de instrução define o campo SQL_DESC_BIND_TYPE no cabeçalho ARD.|  
|SQL_ATTR_ROW_NUMBER (ODBC 2,0)|Um valor de SQLULEN que é o número da linha atual em todo o conjunto de resultados. Se o número da linha atual não puder ser determinado ou não houver nenhuma linha atual, o driver retornará 0.<br /><br /> Esse atributo pode ser recuperado por uma chamada para **SQLGetStmtAttr** , mas não definido por uma chamada para **SQLSetStmtAttr**.|  
|SQL_ATTR_ROW_OPERATION_PTR (ODBC 3,0)|Um \* valor SQLUSMALLINT que aponta para uma matriz de valores SQLUSMALLINT usados para ignorar uma linha durante uma operação em massa usando **SQLSetPos**. Cada valor é definido como SQL_ROW_PROCEED (para a linha a ser incluída na operação em massa) ou SQL_ROW_IGNORE (para a linha a ser excluída da operação em massa). (As linhas não podem ser ignoradas usando essa matriz durante chamadas para **SQLBulkOperations**.)<br /><br /> Esse atributo de instrução pode ser definido como um ponteiro NULL; nesse caso, o driver não retorna valores de status de linha. Esse atributo pode ser definido a qualquer momento, mas o novo valor não é usado até a próxima vez que **SQLSetPos** for chamado.<br /><br /> Para obter mais informações, consulte [atualizando linhas no conjunto de linhas com SQLSetPos](../../../odbc/reference/develop-app/updating-rows-in-the-rowset-with-sqlsetpos.md) e [excluindo linhas no conjunto de linhas com SQLSetPos](../../../odbc/reference/develop-app/deleting-rows-in-the-rowset-with-sqlsetpos.md).<br /><br /> A definição desse atributo de instrução define o campo SQL_DESC_ARRAY_STATUS_PTR no ARD.|  
|SQL_ATTR_ROW_STATUS_PTR (ODBC 3,0)|Um \* valor SQLUSMALLINT que aponta para uma matriz de valores de SQLUSMALLINT que contém valores de status de linha após uma chamada para **SQLFetch** ou **SQLFetchScroll**. A matriz tem tantos elementos quanto há linhas no conjunto de linhas.<br /><br /> Esse atributo de instrução pode ser definido como um ponteiro NULL; nesse caso, o driver não retorna valores de status de linha. Esse atributo pode ser definido a qualquer momento, mas o novo valor não será usado até a próxima vez que **SQLBulkOperations**, **SQLFetch**, **SQLFetchScroll**ou **SQLSetPos** for chamado.<br /><br /> Para obter mais informações, consulte [número de linhas buscadas e status](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> A definição desse atributo de instrução define o campo SQL_DESC_ARRAY_STATUS_PTR no cabeçalho IRD.<br /><br /> Esse atributo é mapeado por um driver ODBC *2. x* para a matriz *rgbRowStatus* em uma chamada para **SQLExtendedFetch**.|  
|SQL_ATTR_ROWS_FETCHED_PTR (ODBC 3,0)|Um \* valor de SQLULEN que aponta para um buffer no qual retornar o número de linhas buscadas após uma chamada para **SQLFetch** ou **SQLFetchScroll**; o número de linhas afetadas por uma operação em massa executada por uma chamada para **SQLSetPos** com um argumento de *operação* de SQL_REFRESH; ou o número de linhas afetadas por uma operação em massa executada por **SQLBulkOperations**. Esse número inclui linhas de erro.<br /><br /> Para obter mais informações, consulte [número de linhas buscadas e status](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> A definição desse atributo de instrução define o campo SQL_DESC_ROWS_PROCESSED_PTR no cabeçalho IRD.<br /><br /> Se a chamada para **SQLFetch** ou **SQLFetchScroll** que preenche o buffer apontado por esse atributo não retornar SQL_SUCCESS ou SQL_SUCCESS_WITH_INFO, o conteúdo do buffer será indefinido.|  
|SQL_ATTR_SIMULATE_CURSOR (ODBC 2,0)|Um valor SQLULEN que especifica se os drivers que simulam instruções UPDATE e DELETE posicionadas garantem que tais instruções afetem apenas uma única linha.<br /><br /> Para simular instruções UPDATE e DELETE posicionadas, a maioria dos drivers constrói uma **atualização** pesquisada ou uma instrução **delete** que contém uma cláusula **Where** que especifica o valor de cada coluna na linha atual. A menos que essas colunas criem uma chave exclusiva, tal instrução pode afetar mais de uma linha.<br /><br /> Para garantir que tais instruções afetem apenas uma linha, o driver determina as colunas em uma chave exclusiva e adiciona essas colunas ao conjunto de resultados. Se um aplicativo garante que as colunas no conjunto de resultados compõem uma chave exclusiva, o driver não precisará fazê-lo. Isso pode reduzir o tempo de execução.<br /><br /> SQL_SC_NON_UNIQUE = o driver não garante que as instruções de atualização ou exclusão posicionadas, afetarão apenas uma linha; é responsabilidade do aplicativo fazer isso. Se uma instrução afetar mais de uma linha, **SQLExecute**, **SQLExecDirect**ou **SQLSetPos** retornará SQLSTATE 01001 (conflito de operação do cursor).<br /><br /> SQL_SC_TRY_UNIQUE = o driver tenta garantir que as instruções de atualização ou exclusão posicionadas no simulado afetem apenas uma linha. O driver sempre executa essas instruções, mesmo que elas possam afetar mais de uma linha, como quando não há nenhuma chave exclusiva. Se uma instrução afetar mais de uma linha, **SQLExecute**, **SQLExecDirect**ou **SQLSetPos** retornará SQLSTATE 01001 (conflito de operação do cursor).<br /><br /> SQL_SC_UNIQUE = o driver garante que as instruções de atualização ou exclusão posicionadas no simulado afetem apenas uma linha. Se o driver não puder garantir isso para uma determinada instrução, **SQLExecDirect** ou **SQLPrepare** retornará um erro.<br /><br /> Se a fonte de dados fornecer suporte nativo do SQL para instruções UPDATE e DELETE posicionadas e o driver não simular cursores, SQL_SUCCESS será retornado quando SQL_SC_UNIQUE for solicitado para SQL_SIMULATE_CURSOR. SQL_SUCCESS_WITH_INFO será retornado se SQL_SC_TRY_UNIQUE ou SQL_SC_NON_UNIQUE for solicitado. Se a fonte de dados fornecer o nível de suporte de SQL_SC_TRY_UNIQUE e o driver não for, SQL_SUCCESS será retornado para SQL_SC_TRY_UNIQUE e SQL_SUCCESS_WITH_INFO será retornado para SQL_SC_NON_UNIQUE.<br /><br /> Se o tipo de simulação de cursor especificado não for suportado pela fonte de dados, o driver substituirá um tipo de simulação diferente e retornará SQLSTATE 01S02 (valor de opção alterado). Por SQL_SC_UNIQUE, o driver substitui, na ordem, SQL_SC_TRY_UNIQUE ou SQL_SC_NON_UNIQUE. Por SQL_SC_TRY_UNIQUE, o driver substitui SQL_SC_NON_UNIQUE.<br /><br /> O padrão é SQL_SC_UNIQUE.<br /><br /> Para obter mais informações, consulte [simulando as instruções UPDATE e DELETE posicionadas](../../../odbc/reference/develop-app/simulating-positioned-update-and-delete-statements.md).|  
|SQL_ATTR_USE_BOOKMARKS (ODBC 2,0)|Um valor de SQLULEN que especifica se um aplicativo usará indicadores com um cursor:<br /><br /> SQL_UB_OFF = off (o padrão)<br /><br /> SQL_UB_VARIABLE = um aplicativo usará indicadores com um cursor e o driver fornecerá indicadores de comprimento variável, se houver suporte. O SQL_UB_FIXED é preterido no ODBC *3. x*. Os aplicativos ODBC *3. x* devem sempre usar indicadores de comprimento variável, mesmo ao trabalhar com drivers ODBC *2. x* (que têm suporte apenas para indicadores de comprimento fixo de 4 bytes). Isso ocorre porque um indicador de comprimento fixo é apenas um caso especial de um indicador de comprimento variável. Ao trabalhar com um driver ODBC *2. x* , o Gerenciador de driver mapeia SQL_UB_VARIABLE para SQL_UB_FIXED.<br /><br /> Para usar indicadores com um cursor, o aplicativo deve especificar esse atributo com o valor SQL_UB_VARIABLE antes de abrir o cursor.<br /><br /> Para obter mais informações, consulte [recuperando indicadores](../../../odbc/reference/develop-app/retrieving-bookmarks.md).|  
  
 [1] essas funções podem ser chamadas de forma assíncrona somente se o descritor for um descritor de implementação, não um descritor de aplicativo.  
  
 Consulte [associação por coluna](../../../odbc/reference/develop-app/column-wise-binding.md) e [Associação de linha](../../../odbc/reference/develop-app/row-wise-binding.md).  
  
## <a name="related-functions"></a>Funções relacionadas  
  
|Para obter informações sobre|Consulte|  
|---------------------------|---------|  
|Cancelando o processamento de instrução|[Função SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Retornando a configuração de um atributo de conexão|[Função SQLGetConnectAttr](../../../odbc/reference/syntax/sqlgetconnectattr-function.md)|  
|Retornando a configuração de um atributo de instrução|[Função SQLGetStmtAttr](../../../odbc/reference/syntax/sqlgetstmtattr-function.md)|  
|Definindo um atributo de conexão|[Função SQLSetConnectAttr](../../../odbc/reference/syntax/sqlsetconnectattr-function.md)|  
|Configurando um único campo do descritor|[Função SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md)|  
  
## <a name="see-also"></a>Consulte Também  
 [Referência da API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Arquivos de cabeçalho ODBC](../../../odbc/reference/install/odbc-header-files.md)
