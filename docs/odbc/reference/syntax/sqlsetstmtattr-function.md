---
title: Função SQLSetSttAttr | Microsoft Docs
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLSetStmtAttr
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLSetStmtAttr
helpviewer_keywords:
- SQLSetStmtAttr function [ODBC]
ms.assetid: 7abc5260-733a-48d4-9974-2d1a6a9ea5f6
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: dfbd2144e677d053f6154dfb3a1df1f6c25d9da5
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 04/14/2020
ms.locfileid: "81287256"
---
# <a name="sqlsetstmtattr-function"></a>Função SQLSetStmtAttr
**Conformidade**  
 Versão introduzida: ODBC 3.0 Standards Compliance: ISO 92  
  
 **Resumo**  
 **SQLSetStmtAttr** define atributos relacionados a uma declaração.  
  
> [!NOTE]
>  Para obter mais informações sobre o que o Driver Manager mapeia essa função para quando um aplicativo ODBC *3.x* estiver trabalhando com um driver ODBC *2.x,* consulte [Funções de substituição de mapeamento para compatibilidade retrógrada de aplicativos](../../../odbc/reference/develop-app/mapping-replacement-functions-for-backward-compatibility-of-applications.md).  
  
## <a name="syntax"></a>Sintaxe  
  
```cpp  
  
SQLRETURN SQLSetStmtAttr(  
     SQLHSTMT      StatementHandle,  
     SQLINTEGER    Attribute,  
     SQLPOINTER    ValuePtr,  
     SQLINTEGER    StringLength);  
```  
  
## <a name="arguments"></a>Argumentos  
 *StatementHandle*  
 [Entrada] Alça de declaração.  
  
 *Atributo*  
 [Entrada] Opção para definir, listada em "Comentários".  
  
 *ValuePtr*  
 [Entrada] Valor a ser associado com *Atributo*. Dependendo do valor do *atributo,* *ValuePtr* será um dos seguintes:  
  
-   Uma alça de descritor ODBC.  
  
-   Um valor SQLUINTEGER.  
  
-   Um valor SQLULEN.  
  
-   Um ponteiro para um dos seguintes:  
  
    -   Uma seqüência de caracteres com término nulo.  
  
    -   Um tampão binário.  
  
    -   Um valor ou matriz do tipo SQLLEN, SQLULEN ou SQLUSMALLINT.  
  
    -   Um valor definido pelo driver.  
  
 Se o argumento *Atributo* for um valor específico do driver, *o ValuePtr* pode ser um inteiro assinado.  
  
 *Stringlength*  
 [Entrada] Se *Atributo* for um atributo definido pelo ODBC e *o ValuePtr* aponta para \*uma seqüência de caracteres ou um buffer binário, esse argumento deve ser o comprimento do *ValuePtr*. Se *Atributo* for um atributo definido pelo ODBC e *o ValuePtr* for um inteiro, *StringLength* será ignorado.  
  
 Se *Atributo* for um atributo definido pelo driver, o aplicativo indicará a natureza do atributo ao Gerenciador de driver, definindo o argumento *StringLength.* *StringLength* pode ter os seguintes valores:  
  
-   Se *ValuePtr* é um ponteiro para uma seqüência de caracteres, então *StringLength* é o comprimento da seqüência ou SQL_NTS.  
  
-   Se *ValuePtr* for um ponteiro para um buffer binário, o aplicativo coloca o resultado da macro SQL_LEN_BINARY_ATTR *(comprimento)* em *StringLength*. Isso coloca um valor negativo em *StringLength*.  
  
-   Se *ValuePtr* é um ponteiro para um valor diferente de uma seqüência de caracteres ou uma seqüência binária, então *StringLength* deve ter o valor SQL_IS_POINTER.  
  
-   Se *ValuePtr* contiver um valor de comprimento fixo, então *StringLength* será SQL_IS_INTEGER ou SQL_IS_UINTEGER, conforme apropriado.  
  
## <a name="returns"></a>Retornos  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR ou SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Diagnósticos  
 Quando **o SQLSetStmtAttr** retornar SQL_ERROR ou SQL_SUCCESS_WITH_INFO, um valor SQLSTATE associado pode ser obtido ligando para **sqlGetDiagRec** com um *HandleType* de SQL_HANDLE_STMT e uma *alça* de *statementHandle*. A tabela a seguir lista os valores SQLSTATE comumente retornados por **SQLSetStmtAttr** e explica cada um no contexto desta função; a notação "(DM)" precede as descrições de SQLSTATEs devolvidas pelo Driver Manager. O código de devolução associado a cada valor SQLSTATE é SQL_ERROR, a menos que seja observado o contrário.  
  
|SQLSTATE|Erro|Descrição|  
|--------------|-----------|-----------------|  
|01000|Aviso geral|Mensagem informacional específica do motorista. (Função retorna SQL_SUCCESS_WITH_INFO.)|  
|01S02|Valor da opção alterado|O driver não suportava o valor especificado no *ValuePtr,* ou o valor especificado no *ValuePtr* era inválido devido às condições de trabalho de implementação, de modo que o motorista substituiu um valor semelhante. (**SQLGetStmtAttr** pode ser chamado para determinar o valor temporariamente substituído.) O valor de substituição é válido para o *StatementHandle* até que o cursor seja fechado, momento em que o atributo da declaração reverte para o valor anterior. Os atributos de declaração que podem ser alterados são:<br /><br /> SQL_ ATTR_CONCURRENCY SQL_ ATTR_CURSOR_TYPE SQL_ ATTR_KEYSET_SIZE SQL_ ATTR_MAX_LENGTH SQL_ ATTR_MAX_ROWS SQL_ ATTR_QUERY_TIMEOUT SQL_ATTR_ROW_ARRAY_SIZE SQL_ ATTR_SIMULATE_CURSOR<br /><br /> (Função retorna SQL_SUCCESS_WITH_INFO.)|  
|08S01|Falha no link de comunicação|O link de comunicação entre o driver e a fonte de dados à qual o driver estava conectado falhou antes da função ser concluída.|  
|24.000|Estado de cursor inválido|O *Atributo* era SQL_ATTR_CONCURRENCY, SQL_ATTR_CURSOR_TYPE, SQL_ATTR_SIMULATE_CURSOR ou SQL_ATTR_USE_BOOKMARKS, e o cursor estava aberto.|  
|HY000|Erro geral|Ocorreu um erro para o qual não havia SQLSTATE específico e para o qual não foi definido sqlSTATE específico para a implementação. A mensagem de erro retornada pelo **SQLGetDiagRec** no * \** buffer MessageText descreve o erro e sua causa.|  
|HY001|Erro de alocação de memória|O driver não conseguiu alocar a memória necessária para suportar a execução ou a conclusão da função.|  
|HY009|Uso inválido do ponteiro nulo|O argumento *Atributo* identificou um atributo de declaração que exigia um atributo de seqüência, e o argumento *ValuePtr* era um ponteiro nulo.|  
|HY010|Erro de seqüência de função|(DM) Uma função de execução assíncrona foi chamada para o cabo de conexão associado ao *StatementHandle*. Esta função assíncrona ainda estava sendo executada quando a função **SQLSetStmtAttr** foi chamada.<br /><br /> (DM) **SQLExecute,** **SQLExecDirect**ou **SQLMoreResults** foram chamados para o *StatementHandle* e retornaram SQL_PARAM_DATA_AVAILABLE. Esta função foi chamada antes de os dados serem recuperados para todos os parâmetros transmitidos.<br /><br /> (DM) Uma função de execução assíncrona foi chamada para o *StatementHandle* e ainda estava sendo executada quando esta função foi chamada.<br /><br /> (DM) **SQLExecute,** **SQLExecDirect,** **SQLBulkOperations**ou **SQLSetPos** foram chamados para o *StatementHandle* e retornaram SQL_NEED_DATA. Essa função foi chamada antes de os dados serem enviados para todos os parâmetros ou colunas de execução de dados.|  
|HY011|Atributo não pode ser definido agora|O *Atributo* foi SQL_ATTR_CONCURRENCY, SQL_ ATTR_CURSOR_TYPE, SQL_ ATTR_SIMULATE_CURSOR ou SQL_ ATTR_USE_BOOKMARKS, e a declaração foi preparada.|  
|HY013|Erro de gerenciamento de memória|A chamada de função não pôde ser processada porque os objetos de memória subjacentes não podiam ser acessados, possivelmente devido às baixas condições de memória.|  
|HY017|Uso inválido de uma alça descritor alocada automaticamente|(DM) O argumento *do Atributo* foi SQL_ATTR_IMP_ROW_DESC ou SQL_ATTR_IMP_PARAM_DESC.<br /><br /> (DM) O argumento *Atributo* foi SQL_ATTR_APP_ROW_DESC ou SQL_ATTR_APP_PARAM_DESC, e o valor no *ValuePtr* era uma alça descritor alocada implicitamente diferente da alça originalmente alocada para o ARD ou APD.|  
|HY024|Valor do atributo inválido|Dado o valor *atributo* especificado, um valor inválido foi especificado no *ValuePtr*. (O Driver Manager retorna este SQLSTATE apenas para atributos de conexão e declaração que aceitam um conjunto discreto de valores, como SQL_ATTR_ACCESS_MODE ou SQL_ ATTR_ASYNC_ENABLE. Para todos os outros atributos de conexão e declaração, o driver deve verificar o valor especificado no *ValuePtr*.)<br /><br /> O argumento *Atributo* foi SQL_ATTR_APP_ROW_DESC ou SQL_ATTR_APP_PARAM_DESC, e *o ValuePtr* foi um manipulador de descritor explicitamente alocado que não está na mesma conexão que o argumento *StatementHandle.*|  
|HY090|Comprimento de seqüência ou buffer inválido|(DM) * \*ValuePtr* é uma seqüência de caracteres, e o argumento *StringLength* foi menor que 0, mas não foi SQL_NTS.|  
|HY092|Identificador de atributo/opção inválido|(DM) O valor especificado para o *atributo argumental* não era válido para a versão do ODBC suportada pelo driver.<br /><br /> (DM) O valor especificado para o *atributo argumentdo* era um atributo somente leitura.|  
|HY117|A conexão está suspensa devido ao estado de transação desconhecido. Somente funções desconectadas e somente leitura são permitidas.|(DM) Para obter mais informações sobre o estado suspenso, consulte [a função SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Recurso opcional não implementado|O valor especificado para o *atributo de* argumento foi um atributo de declaração ODBC válido para a versão do ODBC suportado pelo driver, mas não foi suportado pelo driver.<br /><br /> O argumento *Atributo* foi SQL_ATTR_ASYNC_ENABLE e uma chamada para **sqlGetInfo** com um *InfoType* de SQL_ASYNC_MODE retorna SQL_AM_CONNECTION.<br /><br /> O argumento *atributo* foi SQL_ATTR_ENABLE_AUTO_IPD, e o valor do atributo de conexão SQL_ATTR_AUTO_IPD foi SQL_FALSE.|  
|HYT01|Tempo de tempo de conexão expirado|O período de tempo de tempo de conexão expirou antes que a fonte de dados respondesse à solicitação. O período de tempo de tempo de conexão é definido através **de SQLSetConnectAttr**, SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Driver não suporta esta função|(DM) O driver associado ao *StatementHandle* não suporta a função.|  
|S1118|O driver não suporta notificação assíncrona|Se chamar **SQLSetStmtAttr** para definir SQL_ATTR_ASYNC_STMT_EVENT; A notificação assíncrona não é suportada pelo motorista.|  
  
## <a name="comments"></a>Comentários  
 Os atributos de declaração de uma declaração permanecem em vigor até que sejam alterados por outra chamada para **SQLSetStmtAttr** ou até que a declaração seja retirada ligando para **SQLFreeHandle**. Ligar para **sqlFreeStmt** com a opção SQL_CLOSE, SQL_UNBIND ou SQL_RESET_PARAMS não redefine atributos de declaração.  
  
 Alguns atributos de declaração suportam a substituição de um valor semelhante se a fonte de dados não suportar o valor especificado no *ValuePtr*. Nesses casos, o motorista retorna SQL_SUCCESS_WITH_INFO e SQLSTATE 01S02 (Valor da opção alterado). Por exemplo, se *O Atributo* for SQL_ATTR_CONCURRENCY e *o ValuePtr* for SQL_CONCUR_ROWVER e se a fonte de dados não suportar isso, o driver substitui SQL_CONCUR_VALUES e retorna SQL_SUCCESS_WITH_INFO. Para determinar o valor substituído, um aplicativo chama **SQLGetStmtAttr**.  
  
 O formato de conjunto de informações com *ValuePtr* depende do *Atributo*especificado . **SQLSetStmtAttr** aceita informações de atributos em um dos dois formatos diferentes: uma seqüência de caracteres ou um valor inteiro. O formato de cada um é anotado na descrição do atributo. Este formato se aplica às informações retornadas para cada atributo no **SQLGetStmtAttr**. As seqüências de caracteres apontadas pelo argumento *ValuePtr* do **SQLSetStmtAttr** têm um comprimento de *StringLength*.  
  
> [!NOTE]
>  A capacidade de definir atributos de declaração no nível de conexão, chamando **SQLSetConnectAttr,** foi preterida no ODBC *3.x*. Os aplicativos ODBC *3.x* nunca devem definir atributos de declaração no nível de conexão. Os atributos de declaração ODBC *3.x* não podem ser definidos no nível de conexão, com exceção dos atributos SQL_ATTR_METADATA_ID e SQL_ATTR_ASYNC_ENABLE, que são atributos de conexão e atributos de declaração, e podem ser definidos tanto no nível de conexão quanto no nível de declaração.  
> 
> [!NOTE]
>  Os drivers ODBC *3.x* só precisam suportar essa funcionalidade se trabalharem com aplicativos ODBC *2.x* que definem opções de declaração ODBC *2.x* no nível de conexão. Para obter mais informações, consulte "Definindo opções de declaração no nível de conexão" em [SQLSetConnectOption Mapping](../../../odbc/reference/appendixes/sqlsetconnectoption-mapping.md) no apêndice G: Diretrizes do driver para compatibilidade retrógrada.  
  
## <a name="statement-attributes-that-set-descriptor-fields"></a>Atributos de declaração que definem campos de descritores  
 Muitos atributos de declaração correspondem a um campo de cabeçalho de um descritor. Definir esses atributos realmente resulta na configuração dos campos descritores. A configuração de campos por uma chamada para **SQLSetStmtAttr** em vez de **SQLSetDescField** tem a vantagem de que uma alça descritor não precisa ser obtida para a chamada de função.  
  
> [!CAUTION]  
>  Chamar **SQLSetStmtAttr** para uma declaração pode afetar outras instruções. Isso ocorre quando o APD ou ARD associado à instrução é explicitamente alocado e também está associado a outras declarações. Como **o SQLSetStmtAttr** modifica o APD ou o ARD, as modificações se aplicam a todas as declarações com as quais este descritor está associado. Se este não for o comportamento necessário, o aplicativo deve dissociar este descritor das outras instruções (ligando para **SQLSetStmtAttr** para definir o campo SQL_ATTR_APP_ROW_DESC ou SQL_ATTR_APP_PARAM_DESC para uma alça descritor diferente) antes de chamar **SQLSetStmtAttr** novamente.  
  
 Quando um campo descritor é definido como resultado do atributo de instrução correspondente sendo definido, o campo é definido apenas para os descritores aplicáveis que estão atualmente associados à instrução identificada pelo argumento *StatementHandle,* e a configuração de atributo não afeta nenhum descritor que possa estar associado a essa instrução no futuro. Quando um campo descritor que também é um atributo de instrução é definido por uma chamada para **SQLSetDescField,** o atributo de instrução correspondente é definido. Se um descritor explicitamente alocado for dissociado de uma instrução, um atributo de declaração que corresponde a um campo de cabeçalho será revertido para o valor do campo no descritor implicitamente alocado.  
  
 Quando uma declaração é alocada (consulte [SQLAllocHandle](../../../odbc/reference/syntax/sqlallochandle-function.md)), quatro alças descritores são automaticamente alocadas e associadas à declaração. As alças descritores explicitamente alocadas podem ser associadas à instrução ligando para **o SQLAllocHandle** com um *fHandleType* de SQL_HANDLE_DESC para alocar uma alça de descritor e, em seguida, chamando **SQLSetStmtAttr** para associar a alça do descritor com a instrução.  
  
 Os atributos de declaração na tabela a seguir correspondem aos campos de cabeçalho do descritor.  
  
|Atributo de declaração|Campo de cabeçalho|Desc.|  
|-------------------------|------------------|-----------|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|APD|  
|SQL_ATTR_PARAM_BIND_TYPE|SQL_DESC_BIND_TYPE|APD|  
|SQL_ATTR_PARAM_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|APD|  
|SQL_ATTR_PARAM_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IPD|  
|SQL_ATTR_PARAMS_PROCESSED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IPD|  
|SQL_ATTR_PARAMSET_SIZE|SQL_DESC_ARRAY_SIZE|APD|  
|SQL_ATTR_ROW_ARRAY_SIZE|SQL_DESC_ARRAY_SIZE|Ard|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|Ard|  
|SQL_ATTR_ROW_BIND_TYPE|SQL_DESC_BIND_TYPE|Ard|  
|SQL_ATTR_ROW_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|Ard|  
|SQL_ATTR_ROW_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|Ird|  
|SQL_ATTR_ROWS_FETCHED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|Ird|  
  
## <a name="statement-attributes"></a>Atributos de instrução  
 Os atributos atualmente definidos e a versão do ODBC em que foram introduzidos são mostrados na tabela a seguir; espera-se que mais atributos sejam definidos pelos drivers para aproveitar diferentes fontes de dados. Uma série de atributos é reservada pela ODBC; os desenvolvedores de driver devem reservar valores para seu próprio uso específico do driver do Open Group. Para obter mais informações, consulte [tipos de dados específicos do driver, tipos de descritores, tipos de informações, tipos de diagnóstico e atributos](../../../odbc/reference/develop-app/driver-specific-data-types-descriptor-information-diagnostic.md).  
  
|Atributo|*Conteúdo ValuePtr*|  
|---------------|-------------------------|  
|SQL_ATTR_APP_PARAM_DESC (ODBC 3.0)|A alça para a APD para chamadas subseqüentes para **SQLExecute** e **SQLExecDirect** na alça da declaração. O valor inicial deste atributo é o descritor implicitamente alocado quando a declaração foi inicialmente alocada. Se o valor deste atributo for definido como SQL_NULL_DESC ou a alça originalmente alocada para o descritor, uma alça APD explicitamente alocada que estava anteriormente associada à alça da instrução é dissociada e a alça da instrução reverte para a alça APD implicitamente alocada.<br /><br /> Este atributo não pode ser definido como uma alça de descritor que foi implicitamente alocada para outra declaração ou para outra alça descritor que foi implicitamente definida na mesma declaração; as alças do descritor implicitamente alocadas não podem ser associadas a mais de uma declaração ou alça descritor.|  
|SQL_ATTR_APP_ROW_DESC (ODBC 3.0)|A alça para o ARD para buscas subseqüentes na alça da declaração. O valor inicial deste atributo é o descritor implicitamente alocado quando a declaração foi inicialmente alocada. Se o valor deste atributo for definido como SQL_NULL_DESC ou a alça originalmente alocada para o descritor, uma alça ARD explicitamente alocada que estava anteriormente associada à alça da instrução é dissociada e a alça da instrução reverte para a alça ARD implicitamente alocada.<br /><br /> Este atributo não pode ser definido como uma alça de descritor que foi implicitamente alocada para outra declaração ou para outra alça descritor que foi implicitamente definida na mesma declaração; as alças do descritor implicitamente alocadas não podem ser associadas a mais de uma declaração ou alça descritor.|  
|SQL_ATTR_ASYNC_ENABLE (ODBC 1.0)|Um valor SQLULEN que especifica se uma função chamada com a declaração especificada é executada de forma assíncrona:<br /><br /> SQL_ASYNC_ENABLE_OFF = Desativar o suporte de execução assíncrona do nível de declaração (o padrão).<br /><br /> SQL_ASYNC_ENABLE_ON = Habilitar suporte de execução assíncrono de nível de declaração.<br /><br /> Para obter mais informações, consulte [Execução Assíncrona (Método de Votação)](../../../odbc/reference/develop-app/asynchronous-execution-polling-method.md).<br /><br /> Para drivers com suporte de execução assíncrono de nível de declaração, o atributo de declaração SQL_ATTR_ASYNC_ENABLE é lido apenas. Seu valor é o mesmo que o valor do atributo de nível de conexão com o mesmo nome no momento em que a alça da declaração foi alocada.<br /><br /> Chamando **SQLSetStmtAttr** para definir SQL_ATTR_ASYNC_ENABLE quando o *infoType* SQL_ASYNC_MODE retornar SQL_AM_CONNECTION retorna SQLSTATE HYC00 (recurso opcional não implementado). Para obter mais informações, consulte [SQLSetConnectAttr function](../../../odbc/reference/syntax/sqlsetconnectattr-function.md) para obter mais informações.|  
|SQL_ATTR_ASYNC_STMT_EVENT (ODBC 3.8)|Um valor SQLPOINTER que é uma alça de evento.<br /><br /> A notificação de conclusão de funções assíncronas é ativada ligando para **SQLSetStmtAttr** para definir o atributo **SQL_ATTR_ASYNC_STMT_EVENT** e especificar o cabo de evento.|  
|SQL_ATTR_ASYNC_STMT_PCALLBACK (ODBC 3.8)|Um SQLPOINTER para a função de retorno de chamada assíncrona.<br /><br /> Apenas o Gerenciador de Driver pode chamar a função **SQLSetStmtAttr** de um driver com este atributo.|  
|SQL_ATTR_ASYNC_STMT_PCONTEXT (ODBC 3.8)|Um SQLPOINTER para a estrutura de contexto<br /><br /> Apenas o Gerenciador de Driver pode chamar a função **SQLSetStmtAttr** de um driver com este atributo.|  
|SQL_ATTR_CONCURRENCY (ODBC 2.0)|Um valor SQLULEN que especifica a concorrência do cursor:<br /><br /> SQL_CONCUR_READ_ONLY = Cursor é somente leitura. Não são permitidas atualizações.<br /><br /> SQL_CONCUR_LOCK = O cursor usa o nível mais baixo de bloqueio suficiente para garantir que a linha possa ser atualizada.<br /><br /> SQL_CONCUR_ROWVER = O Cursor usa um controle de concorrência otimista, comparando versões de linha como SQLBase ROWID ou Sybase TIMESTAMP.<br /><br /> SQL_CONCUR_VALUES = Cursor utiliza controle de concorrência otimista, comparando valores.<br /><br /> O valor padrão para SQL_ATTR_CONCURRENCY é SQL_CONCUR_READ_ONLY.<br /><br /> Este atributo não pode ser especificado para um cursor aberto. Para obter mais informações, consulte [Tipos de Concorrência](../../../odbc/reference/develop-app/concurrency-types.md).<br /><br /> Se o *atributo* SQL_ATTR_CURSOR_TYPE for alterado para um tipo que não suporta o valor atual de SQL_ATTR_CONCURRENCY, o valor de SQL_ATTR_CONCURRENCY será alterado no momento da execução e um aviso emitido quando **SQLExecDirect** ou **SQLPrepare** for chamado.<br /><br /> Se o driver suportar a declaração **SELECT FOR UPDATE** e tal declaração for executada enquanto o valor de SQL_ATTR_CONCURRENCY estiver definido como SQL_CONCUR_READ_ONLY, um erro será retornado. Se o valor de SQL_ATTR_CONCURRENCY for alterado para um valor que o driver suporta por algum valor de SQL_ATTR_CURSOR_TYPE mas não para o valor atual de SQL_ATTR_CURSOR_TYPE, o valor de SQL_ATTR_CURSOR_TYPE será alterado no momento da execução e SQLSTATE 01S02 (valor da opção alterado) é emitido quando **SQLExecDirect** ou **SQLPrepare** é chamado.<br /><br /> Se a simultâneo especificada não for suportada pela fonte de dados, o driver substituirá uma concorrência diferente e retorna SQLSTATE 01S02 (valor da opção alterado). Para SQL_CONCUR_VALUES, o motorista substitui SQL_CONCUR_ROWVER, e vice-versa. Para SQL_CONCUR_LOCK, o motorista substitui, em ordem, SQL_CONCUR_ROWVER ou SQL_CONCUR_VALUES. A validade do valor substituído não é verificada até o tempo de execução.<br /><br /> Para obter mais informações sobre a relação entre SQL_ATTR_CONCURRENCY e os outros atributos do cursor, consulte [Características do Cursor e Tipo de Cursor](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_SCROLLABLE (ODBC 3.0)|Um valor SQLULEN que especifica o nível de suporte que o aplicativo requer. A definição desse atributo afeta chamadas subseqüentes para **SQLExecDirect** e **SQLExecute**.<br /><br /> SQL_NONSCROLLABLE = Não são necessários cursores roláveis na alça da declaração. Se o aplicativo chamar **SQLFetchScroll** nesta alça, o único valor válido do *FetchOrientation* será SQL_FETCH_NEXT. Esse é o padrão.<br /><br /> SQL_SCROLLABLE = Cursores roláveis são necessários na alça da declaração. Ao chamar **SQLFetchScroll,** o aplicativo pode especificar qualquer valor válido de *FetchOrientation,* obtendo o posicionamento do cursor em modos diferentes do modo seqüencial.<br /><br /> Para obter mais informações sobre cursores roláveis, consulte [Cursors Roláveis](../../../odbc/reference/develop-app/scrollable-cursors.md). Para obter mais informações sobre a relação entre SQL_ATTR_CURSOR_SCROLLABLE e os outros atributos do cursor, consulte [Características do Cursor e Tipo de Cursor](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md)|  
|SQL_ATTR_CURSOR_SENSITIVITY (ODBC 3.0)|Um valor SQLULEN que especifica se os cursores na alça da declaração tornam visíveis as alterações feitas em um resultado definido por outro cursor. A definição desse atributo afeta chamadas subseqüentes para **SQLExecDirect** e **SQLExecute**. Um aplicativo pode ler de volta o valor deste atributo para obter seu estado inicial ou seu estado como mais recentemente definido pelo aplicativo.<br /><br /> SQL_UNSPECIFIED = Não é especificado qual é o tipo de cursor e se os cursores na alça da declaração tornam visíveis as alterações feitas em um resultado definido por outro cursor. Os cursors na alça da declaração podem tornar visíveis nenhuma, algumas ou todas essas alterações. Esse é o padrão.<br /><br /> SQL_INSENSITIVE = Todos os cursores da alça da declaração mostram o conjunto de resultados sem refletir quaisquer alterações feitas a ele por qualquer outro cursor. Os cursores insensíveis são somente leitura. Isso corresponde a um cursor estático, que tem uma simultuância que é somente leitura.<br /><br /> SQL_SENSITIVE = Todos os cursores da alça da declaração tornam visíveis todas as alterações feitas em um resultado definido por outro cursor.<br /><br /> Para obter mais informações sobre a relação entre SQL_ATTR_CURSOR_SENSITIVITY e os outros atributos do cursor, consulte [Características do Cursor e Tipo de Cursor](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_TYPE (ODBC 2.0)|Um valor SQLULEN que especifica o tipo de cursor:<br /><br /> SQL_CURSOR_FORWARD_ONLY = O cursor só rola para a frente.<br /><br /> SQL_CURSOR_STATIC = Os dados no conjunto de resultados são estáticos.<br /><br /> SQL_CURSOR_KEYSET_DRIVEN = O driver salva e usa as teclas para o número de linhas especificadas no atributo de declaração SQL_ATTR_KEYSET_SIZE.<br /><br /> SQL_CURSOR_DYNAMIC = O driver salva e usa apenas as teclas para as linhas no conjunto de linhas.<br /><br /> O valor padrão é SQL_CURSOR_FORWARD_ONLY. Este atributo não pode ser especificado após a declaração SQL ter sido preparada.<br /><br /> Se o tipo de cursor especificado não for suportado pela fonte de dados, o driver substituirá um tipo de cursor diferente e devolverá SQLSTATE 01S02 (valor da opção alterado). Para um cursor misto ou dinâmico, o driver substitui, em ordem, um cursor estático ou orientado por chave. Para um cursor orientado por chave, o driver substitui um cursor estático.<br /><br /> Para obter mais informações sobre os tipos de cursor roláveis, consulte [Tipos de cursor roláveis](../../../odbc/reference/develop-app/scrollable-cursor-types.md). Para obter mais informações sobre a relação entre SQL_ATTR_CURSOR_TYPE e os outros atributos do cursor, consulte [Características do Cursor e Tipo de Cursor](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_ENABLE_AUTO_IPD (ODBC 3.0)|Um valor SQLULEN que especifica se a população automática do IPD é realizada:<br /><br /> SQL_TRUE = Ativa a população automática do IPD após uma chamada para **SQLPrepare**. SQL_FALSE = Desliga a população automática do IPD após uma chamada para **SQLPrepare**. (Um aplicativo ainda pode obter informações de campo IPD ligando para **SQLDescribeParam**, se suportado.) O valor padrão do atributo de declaração SQL_ATTR_ENABLE_AUTO_IPD é SQL_FALSE. Para obter mais informações, consulte [População Automática do IPD](../../../odbc/reference/develop-app/automatic-population-of-the-ipd.md).|  
|SQL_ATTR_FETCH_BOOKMARK_PTR (ODBC 3.0)|Um SQLLEN \* que aponta para um valor binário de marcador. Quando **sQLFetchScroll** é chamado com *fFetchOrientation* igual a SQL_FETCH_BOOKMARK, o driver pega o valor do marcador a partir deste campo. Este campo é padrão para um ponteiro nulo. Para obter mais informações, consulte [Scrolling by Bookmark](../../../odbc/reference/develop-app/scrolling-by-bookmark.md).<br /><br /> O valor apontado por este campo não é usado para excluir por marcador, atualizar por marcador ou buscar por operações de marcadores em **SQLBulkOperations**, que usam marcadores armazenados em cache em buffers de conjunto de linhas.|  
|SQL_ATTR_IMP_PARAM_DESC (ODBC 3.0)|A alça do IPD. O valor deste atributo é o descritor alocado quando a declaração foi inicialmente alocada. O aplicativo não pode definir esse atributo.<br /><br /> Este atributo pode ser recuperado por uma chamada para **SQLGetStmtAttr,** mas não definido por uma chamada para **SQLSetStmtAttr**.|  
|SQL_ATTR_IMP_ROW_DESC (ODBC 3.0)|A alça do IRD. O valor deste atributo é o descritor alocado quando a declaração foi inicialmente alocada. O aplicativo não pode definir esse atributo.<br /><br /> Este atributo pode ser recuperado por uma chamada para **SQLGetStmtAttr,** mas não definido por uma chamada para **SQLSetStmtAttr**.|  
|SQL_ATTR_KEYSET_SIZE (ODBC 2.0)|Um SQLULEN que especifica o número de linhas no conjunto de chaves para um cursor orientado por conjuntos de chaves. Se o tamanho do conjunto de chaves for 0 (o padrão), o cursor será totalmente orientado por keyset. Se o tamanho do conjunto de tecla for maior que 0, o cursor será misturado (orientado por keyset dentro do conjunto de chaves e dinâmico fora do conjunto de chaves). O tamanho padrão do conjunto de chaves é 0. Para obter mais informações sobre cursores orientados por chave, consulte [Cursors orientados por keyset](../../../odbc/reference/develop-app/keyset-driven-cursors.md).<br /><br /> Se o tamanho especificado exceder o tamanho máximo do conjunto de chaves, o driver substitui esse tamanho e retorna SQLSTATE 01S02 (valor da opção alterado).<br /><br /> **SQLFetch** ou **SQLFetchScroll** retorna um erro se o tamanho do conjunto de chaves for maior que 0 e menor do que o tamanho do conjunto de linhas.|  
|SQL_ATTR_MAX_LENGTH (ODBC 1.0)|Um valor SQLULEN que especifica a quantidade máxima de dados que o driver retorna de um caractere ou coluna binária. Se *o ValuePtr* for menor do que o comprimento dos dados disponíveis, o **SQLFetch** ou **o SQLGetData** truncarão os dados e os retornos SQL_SUCCESS. Se *o ValuePtr* for 0 (o padrão), o driver tentará retornar todos os dados disponíveis.<br /><br /> Se o comprimento especificado for menor do que a quantidade mínima de dados que a fonte de dados pode retornar ou maior do que a quantidade máxima de dados que a fonte de dados pode retornar, o driver substitui esse valor e retorna SQLSTATE 01S02 (valor da opção alterado).<br /><br /> O valor deste atributo pode ser definido em um cursor aberto; no entanto, a configuração pode não ter efeito imediato, nesse caso o driver retornará SQLSTATE 01S02 (valor da opção alterado) e redefinirá o atributo ao seu valor original.<br /><br /> Esse atributo destina-se a reduzir o tráfego de rede e deve ser suportado somente quando a fonte de dados (em oposição ao driver) em um driver de vários níveis pode implementá-lo. Este mecanismo não deve ser usado por aplicativos para truncar dados; para truncar dados recebidos, um aplicativo deve especificar o comprimento máximo de buffer no argumento *BufferLength* no **SQLBindCol** ou **SQLGetData**.|  
|SQL_ATTR_MAX_ROWS (ODBC 1.0)|Um valor SQLULEN correspondente ao número máximo de linhas para retornar ao aplicativo para uma instrução **SELECT.** Se \* *ValuePtr* for igual a 0 (o padrão), o driver retorna todas as linhas.<br /><br /> Este atributo visa reduzir o tráfego de rede. Conceitualmente, ele é aplicado quando o conjunto de resultados é criado e limita o resultado definido para as primeiras linhas *ValuePtr.* Se o número de linhas no conjunto de resultados for maior que *o ValuePtr,* o conjunto de resultados será truncado.<br /><br /> SQL_ATTR_MAX_ROWS se aplica a todos os conjuntos de resultados da *Declaração,* incluindo aqueles devolvidos por funções de catálogo. SQL_ATTR_MAX_ROWS estabelece um máximo para o valor da contagem de linhas do cursor.<br /><br /> Um driver não deve emular SQL_ATTR_MAX_ROWS comportamento para **SQLFetch** ou **SQLFetchScroll** (se as limitações de tamanho do conjunto de resultados não puderem ser implementadas na fonte de dados) se não puder garantir que SQL_ATTR_MAX_ROWS serão implementadas corretamente.<br /><br /> É definido pelo driver se SQL_ATTR_MAX_ROWS se aplica a outras instruções que não sejam instruções SELECT (como funções de catálogo).<br /><br /> O valor deste atributo pode ser definido em um cursor aberto; no entanto, a configuração pode não ter efeito imediato, nesse caso o driver retornará SQLSTATE 01S02 (valor da opção alterado) e redefinirá o atributo ao seu valor original.|  
|SQL_ATTR_METADATA_ID (ODBC 3.0)|Um valor SQLULEN que determina como os argumentos de seqüência de funções de catálogo são tratados.<br /><br /> Se SQL_TRUE, o argumento de seqüência de funções de catálogo são tratados como identificadores. O caso não é significativo. Para cordas não limitadas, o driver remove todos os espaços de arrasto e a corda é dobrada para maiúsculas. Para cordas delimitadas, o motorista remove qualquer espaço de liderança ou de trilha e leva tudo o que está entre os delimitadores literalmente. Se um desses argumentos estiver definido como um ponteiro nulo, a função retorna SQL_ERROR e SQLSTATE HY009 (uso inválido do ponteiro nulo).<br /><br /> Se SQL_FALSE, os argumentos de seqüência de funções de catálogo não são tratados como identificadores. O caso é significativo. Eles podem conter um padrão de pesquisa de strings ou não, dependendo do argumento.<br /><br /> O valor padrão é SQL_FALSE.<br /><br /> O argumento *TableType* do **SQLTables**, que leva uma lista de valores, não é afetado por esse atributo.<br /><br /> SQL_ATTR_METADATA_ID também podem ser definidos no nível de conexão. (Ele e SQL_ATTR_ASYNC_ENABLE são os únicos atributos de declaração que também são atributos de conexão.)<br /><br /> Para obter mais informações, consulte [Argumentos em Funções de Catálogo](../../../odbc/reference/develop-app/arguments-in-catalog-functions.md).|  
|SQL_ATTR_NOSCAN (ODBC 1.0)|Um valor SQLULEN que indica se o driver deve escanear as strings SQL em busca de seqüências de fuga:<br /><br /> SQL_NOSCAN_OFF = O driver escaneia as seqüências SQL em busca de seqüências de fuga (o padrão).<br /><br /> SQL_NOSCAN_ON = O driver não escaneia as strings SQL em busca de seqüências de fuga. Em vez disso, o motorista envia a declaração diretamente para a fonte de dados.<br /><br /> Para obter mais informações, consulte [Sequências de Fuga no ODBC](../../../odbc/reference/develop-app/escape-sequences-in-odbc.md).|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR (ODBC 3.0)|Um valor SQLULEN * que aponta para uma compensação adicionada aos ponteiros para alterar a vinculação de parâmetros dinâmicos. Se este campo não for nulo, o driver defaz referência ao ponteiro, adiciona o valor desreferenciado a cada um dos campos diferidos no registro do descritor (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR e SQL_DESC_OCTET_LENGTH_PTR) e usa os novos valores de ponteiro quando vinculado. Está definido como nulo por padrão.<br /><br /> O deslocamento de ligação é sempre adicionado diretamente aos campos SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR e SQL_DESC_OCTET_LENGTH_PTR. Se a compensação for alterada para um valor diferente, o novo valor ainda será adicionado diretamente ao valor no campo descritor. O novo deslocamento não é adicionado ao valor de campo mais quaisquer deslocamentos anteriores.<br /><br /> Para obter mais informações, consulte [Deslocamentos de vinculação de parâmetros](../../../odbc/reference/develop-app/parameter-binding-offsets.md).<br /><br /> A definição deste atributo de declaração define o campo SQL_DESC_BIND_OFFSET_PTR no cabeçalho APD.|  
|SQL_ATTR_PARAM_BIND_TYPE (ODBC 3.0)|Um valor SQLULEN que indica a orientação de vinculação a ser usada para parâmetros dinâmicos.<br /><br /> Este campo está definido como SQL_PARAM_BIND_BY_COLUMN (o padrão) para selecionar a vinculação em termos de coluna.<br /><br /> Para selecionar a vinculação em termos de linha, este campo é definido para o comprimento da estrutura ou uma instância de um buffer que será vinculado a um conjunto de parâmetros dinâmicos. Este comprimento deve incluir espaço para todos os parâmetros vinculados e qualquer preenchimento da estrutura ou tampão para garantir que quando o endereço de um parâmetro bound for incrementado com o comprimento especificado, o resultado apontará para o início do mesmo parâmetro no próximo conjunto de parâmetros. Ao utilizar o *tamanho do* operador no ANSI C, esse comportamento é garantido.<br /><br /> Para obter mais informações, consulte [Matrizes de vinculação de parâmetros](../../../odbc/reference/develop-app/binding-arrays-of-parameters.md).<br /><br /> A definição deste atributo de declaração define o campo SQL_DESC_ BIND_TYPE no cabeçalho APD.|  
|SQL_ATTR_PARAM_OPERATION_PTR (ODBC 3.0)|Um valor SQLUSMALLINT \* que aponta para uma matriz de valores SQLUSMALLINT usado para ignorar um parâmetro durante a execução de uma declaração SQL. Cada valor é definido como SQL_PARAM_PROCEED (para que o parâmetro seja executado) ou SQL_PARAM_IGNORE (para que o parâmetro seja ignorado).<br /><br /> Um conjunto de parâmetros pode ser ignorado durante o processamento definindo o valor de status na matriz apontada por SQL_DESC_ARRAY_STATUS_PTR na APD para SQL_PARAM_IGNORE. Um conjunto de parâmetros é processado se seu valor de status for definido como SQL_PARAM_PROCEED ou se nenhum elemento na matriz for definido.<br /><br /> Este atributo de declaração pode ser definido como um ponteiro nulo, nesse caso o driver não retorna valores de status do parâmetro. Este atributo pode ser definido a qualquer momento, mas o novo valor não é usado até a próxima vez que **SQLExecDirect** ou **SQLExecute** forchamado.<br /><br /> Este atributo é ignorado quando não há parâmetro vinculado.<br /><br /> Para obter mais informações, consulte [Usando matrizes de parâmetros](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> A definição deste atributo de declaração define o campo SQL_DESC_ARRAY_STATUS_PTR no cabeçalho APD.|  
|SQL_ATTR_PARAM_STATUS_PTR (ODBC 3.0)|Um valor SQLUSMALLINT \* que aponta para uma matriz de valores SQLUSMALLINT contendo informações de status para cada linha de valores de parâmetros após uma chamada para **SQLExecute** ou **SQLExecDirect**. Este campo só é necessário se PARAMSET_SIZE for maior que 1.<br /><br /> Os valores de status podem conter os seguintes valores:<br /><br /> SQL_PARAM_SUCCESS: A declaração SQL foi executada com sucesso para este conjunto de parâmetros.<br /><br /> SQL_PARAM_SUCCESS_WITH_INFO: A declaração SQL foi executada com sucesso para este conjunto de parâmetros; no entanto, as informações de alerta estão disponíveis na estrutura de dados de diagnóstico.<br /><br /> SQL_PARAM_ERROR: Houve um erro no processamento desse conjunto de parâmetros. Informações adicionais de erro estão disponíveis na estrutura de dados de diagnóstico.<br /><br /> SQL_PARAM_UNUSED: Este conjunto de parâmetros não foi utilizado, possivelmente devido ao fato de que algum conjunto de parâmetros anteriores causou um erro que abortou o processamento adicional, ou porque SQL_PARAM_IGNORE foi definido para esse conjunto de parâmetros na matriz especificada pelo SQL_ATTR_PARAM_OPERATION_PTR.<br /><br /> SQL_PARAM_DIAG_UNAVAILABLE: O driver trata matrizes de parâmetros como uma unidade monolítica e, portanto, não gera esse nível de informação de erro.<br /><br /> Este atributo de declaração pode ser definido como um ponteiro nulo, nesse caso o driver não retorna valores de status do parâmetro. Este atributo pode ser definido a qualquer momento, mas o novo valor não é usado até a próxima vez que **SQLExecute** ou **SQLExecDirect** forem chamados. Observe que a configuração deste atributo pode afetar o comportamento do parâmetro de saída implementado pelo driver.<br /><br /> Para obter mais informações, consulte [Usando matrizes de parâmetros](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> A definição deste atributo de declaração define o campo SQL_DESC_ARRAY_STATUS_PTR no cabeçalho IPD.|  
|SQL_ATTR_PARAMS_PROCESSED_PTR (ODBC 3.0)|Um campo de \* registro SQLULEN que aponta para um buffer no qual retornar o número de conjuntos de parâmetros que foram processados, incluindo conjuntos de erros. Nenhum número será devolvido se este for um ponteiro nulo.<br /><br /> A definição deste atributo de declaração define o campo SQL_DESC_ROWS_PROCESSED_PTR no cabeçalho IPD.<br /><br /> Se a chamada para **SQLExecDirect** ou **SQLExecute** que preenche o buffer apontado por esse atributo não retornar SQL_SUCCESS ou SQL_SUCCESS_WITH_INFO, o conteúdo do buffer será indefinido.<br /><br /> Para obter mais informações, consulte [Usando matrizes de parâmetros](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).|  
|SQL_ATTR_PARAMSET_SIZE (ODBC 3.0)|Um valor SQLULEN que especifica o número de valores para cada parâmetro. Se SQL_ATTR_PARAMSET_SIZE for maior que 1, SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR e SQL_DESC_OCTET_LENGTH_PTR do APD, apd, apontará para matrizes. A cardinalidade de cada matriz é igual ao valor deste campo.<br /><br /> Este atributo é ignorado quando não há parâmetro vinculado.<br /><br /> Para obter mais informações, consulte [Usando matrizes de parâmetros](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> A definição deste atributo de declaração define o campo SQL_DESC_ARRAY_SIZE no cabeçalho APD.|  
|SQL_ATTR_QUERY_TIMEOUT (ODBC 1.0)|Um valor SQLULEN correspondente ao número de segundos para esperar que uma instrução SQL seja executada antes de retornar ao aplicativo. Se *ValuePtr* for igual a 0 (padrão), não haverá intervalo.<br /><br /> Se o tempo limite especificado exceder o tempo máximo na fonte de dados ou for menor do que o tempo mínimo, o **SQLSetStmtAttr** substitui esse valor e retorna SQLSTATE 01S02 (valor da opção alterado).<br /><br /> Observe que o aplicativo não precisa ligar para **o SQLCloseCursor** para reutilizar a declaração se uma declaração **SELECT** estiver desatada.<br /><br /> O tempo limite de consulta definido neste atributo de declaração é válido nos modos síncrono e assíncrono.|  
|SQL_ATTR_RETRIEVE_DATA (ODBC 2.0)|Um valor SQLULEN:<br /><br /> SQL_RD_ON = **SQLFetchScroll** e, em ODBC *3.x,* **SQLFetch** recuperar dados depois de posicionar o cursor para o local especificado. Esse é o padrão.<br /><br /> SQL_RD_OFF = **SQLFetchScroll** e, em ODBC *3.x*, **SQLFetch** não recuperam dados após posicionar o cursor.<br /><br /> Ao definir SQL_RETRIEVE_DATA para SQL_RD_OFF, um aplicativo pode verificar se existe uma linha ou recuperar um marcador para a linha sem incorrer na sobrecarga das linhas de recuperação. Para obter mais informações, consulte [Scrolling and Fetching Rows](../../../odbc/reference/develop-app/scrolling-and-fetching-rows-odbc.md).<br /><br /> O valor deste atributo pode ser definido em um cursor aberto; no entanto, a configuração pode não ter efeito imediato, nesse caso o driver retornará SQLSTATE 01S02 (valor da opção alterado) e redefinirá o atributo ao seu valor original.|  
|SQL_ATTR_ROW_ARRAY_SIZE (ODBC 3.0)|Um valor SQLULEN que especifica o número de linhas retornadas por cada chamada para **SQLFetch** ou **SQLFetchScroll**. É também o número de linhas em uma matriz de marcadores usada em uma operação de marcador em massa em **SQLBulkOperations**. O valor padrão é 1.<br /><br /> Se o tamanho de conjunto de linhas especificado exceder o tamanho máximo do conjunto de linhas suportado pela fonte de dados, o driver substituirá esse valor e retorna o SQLSTATE 01S02 (valor da opção alterado).<br /><br /> Para obter mais informações, consulte [Rowset Size](../../../odbc/reference/develop-app/rowset-size.md).<br /><br /> A definição deste atributo de declaração define o campo SQL_DESC_ARRAY_SIZE no cabeçalho ARD.|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR (ODBC 3.0)|Um valor SQLULEN * que aponta para uma compensação adicionada a ponteiros para alterar a vinculação de dados da coluna. Se este campo não for nulo, o driver defaz referência ao ponteiro, adiciona o valor desreferenciado a cada um dos campos diferidos no registro do descritor (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR e SQL_DESC_OCTET_LENGTH_PTR) e usa os novos valores de ponteiro quando vinculado. Está definido como nulo por padrão.<br /><br /> A definição deste atributo de declaração define o campo SQL_DESC_BIND_OFFSET_PTR no cabeçalho ARD.|  
|SQL_ATTR_ROW_BIND_TYPE (ODBC 1.0)|Um valor SQLULEN que define a orientação de vinculação a ser usada quando **SQLFetch** ou **SQLFetchScroll** é chamado na declaração associada. A vinculação em termos de coluna é selecionada definindo o valor para SQL_BIND_BY_COLUMN. A vinculação em termos de linha é selecionada definindo o valor para o comprimento de uma estrutura ou uma instância de um buffer no qual as colunas de resultado serão vinculadas.<br /><br /> Se um comprimento for especificado, ele deve incluir espaço para todas as colunas vinculadas e qualquer preenchimento da estrutura ou buffer para garantir que quando o endereço de uma coluna vinculada for incrementado com o comprimento especificado, o resultado apontará para o início da mesma coluna na próxima linha. Ao utilizar o **tamanho do** operador com estruturas ou sindicatos no ANSI C, esse comportamento é garantido.<br /><br /> A vinculação em termos de coluna é a orientação de vinculação padrão para **SQLFetch** e **SQLFetchScroll**.<br /><br /> Para obter mais informações, consulte [Colunas de vinculação para uso com cursores de bloco](../../../odbc/reference/develop-app/binding-columns-for-use-with-block-cursors.md).<br /><br /> A definição deste atributo de declaração define o campo SQL_DESC_BIND_TYPE no cabeçalho ARD.|  
|SQL_ATTR_ROW_NUMBER (ODBC 2.0)|Um valor SQLULEN que é o número da linha atual em todo o conjunto de resultados. Se o número da linha atual não puder ser determinado ou não houver uma linha atual, o motorista retorna 0.<br /><br /> Este atributo pode ser recuperado por uma chamada para **SQLGetStmtAttr,** mas não definido por uma chamada para **SQLSetStmtAttr**.|  
|SQL_ATTR_ROW_OPERATION_PTR (ODBC 3.0)|Um valor SQLUSMALLINT \* que aponta para uma matriz de valores SQLUSMALLINT usado para ignorar uma linha durante uma operação em massa usando **SQLSetPos**. Cada valor é definido como SQL_ROW_PROCEED (para que a linha seja incluída na operação a granel) ou SQL_ROW_IGNORE (para que a linha seja excluída da operação em massa). (As linhas não podem ser ignoradas usando essa matriz durante as chamadas para **SQLBulkOperations**.)<br /><br /> Este atributo de declaração pode ser definido como um ponteiro nulo, nesse caso o driver não retorna os valores de status da linha. Este atributo pode ser definido a qualquer momento, mas o novo valor não é usado até a próxima vez que **SQLSetPos** for chamado.<br /><br /> Para obter mais informações, consulte [Atualizar linhas no conjunto de linhas com SQLSetPos](../../../odbc/reference/develop-app/updating-rows-in-the-rowset-with-sqlsetpos.md) e excluir linhas no conjunto de linhas com [SQLSetPos](../../../odbc/reference/develop-app/deleting-rows-in-the-rowset-with-sqlsetpos.md).<br /><br /> A definição deste atributo de declaração define o campo SQL_DESC_ARRAY_STATUS_PTR no ARD.|  
|SQL_ATTR_ROW_STATUS_PTR (ODBC 3.0)|Um valor SQLUSMALLINT \* que aponta para uma matriz de valores SQLUSMALLINT contendo valores de status de linha após uma chamada para **SQLFetch** ou **SQLFetchScroll**. A matriz tem tantos elementos quanto há linhas no conjunto de linhas.<br /><br /> Este atributo de declaração pode ser definido como um ponteiro nulo, nesse caso o driver não retorna os valores de status da linha. Este atributo pode ser definido a qualquer momento, mas o novo valor não é usado até a próxima vez que **SQLBulkOperations,** **SQLFetch,** **SQLFetchScroll**ou **SQLSetPos** forem chamados.<br /><br /> Para obter mais informações, consulte [Número de linhas buscadas e status](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> A definição deste atributo de declaração define o campo SQL_DESC_ARRAY_STATUS_PTR no cabeçalho IRD.<br /><br /> Este atributo é mapeado por um driver ODBC *2.x* para a matriz *rgbRowStatus* em uma chamada para **SQLExtendedFetch**.|  
|SQL_ATTR_ROWS_FETCHED_PTR (ODBC 3.0)|Um valor SQLULEN \* que aponta para um buffer no qual retornar o número de linhas buscadas após uma chamada para **SQLFetch** ou **SQLFetchScroll**; o número de linhas afetadas por uma operação em massa realizada por uma chamada para **SQLSetPos** com um argumento de *Operação* de SQL_REFRESH; ou o número de linhas afetadas por uma operação em massa realizada pela **SQLBulkOperations**. Este número inclui linhas de erro.<br /><br /> Para obter mais informações, consulte [Número de linhas buscadas e status](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> A definição deste atributo de declaração define o campo SQL_DESC_ROWS_PROCESSED_PTR no cabeçalho IRD.<br /><br /> Se a chamada para **SQLFetch** ou **SQLFetchScroll** que preenche o buffer apontado por este atributo não retornar SQL_SUCCESS ou SQL_SUCCESS_WITH_INFO, o conteúdo do buffer será indefinido.|  
|SQL_ATTR_SIMULATE_CURSOR (ODBC 2.0)|Um valor SQLULEN que especifica se os drivers que simulam as instruções de atualização posicionada e excluem garantem que tais instruções afetam apenas uma única linha.<br /><br /> Para simular as declarações de atualização e exclusão posicionadas, a maioria dos drivers constrói uma instrução **UPDATE** ou **DELETE** pesquisada contendo uma cláusula **WHERE** que especifica o valor de cada coluna na linha atual. A menos que essas colunas compõem uma chave única, tal afirmação pode afetar mais de uma linha.<br /><br /> Para garantir que tais instruções afetem apenas uma linha, o driver determina as colunas em uma tecla única e adiciona essas colunas ao conjunto de resultados. Se um aplicativo garantir que as colunas no conjunto de resultados compõem uma chave única, o driver não é obrigado a fazê-lo. Isso pode reduzir o tempo de execução.<br /><br /> SQL_SC_NON_UNIQUE = O driver não garante que as instruções de atualização ou exclusão de posições simuladas afetarão apenas uma linha; é responsabilidade do aplicativo fazê-lo. Se uma declaração afetar mais de uma linha, **SQLExecute,** **SQLExecDirect**ou **SQLSetPos** retornarão SQLSTATE 01001 (conflito de operação cursor).<br /><br /> SQL_SC_TRY_UNIQUE = O driver tenta garantir que as instruções de atualização ou exclusão de posições simuladas afetem apenas uma linha. O driver sempre executa tais instruções, mesmo que possam afetar mais de uma linha, como quando não há uma chave única. Se uma declaração afetar mais de uma linha, **SQLExecute,** **SQLExecDirect**ou **SQLSetPos** retornarão SQLSTATE 01001 (conflito de operação cursor).<br /><br /> SQL_SC_UNIQUE = O driver garante que as instruções de atualização posicionada simuladas ou excluem a afetar apenas uma linha. Se o driver não puder garantir isso para uma determinada declaração, **O SQLExecDirect** ou **o SQLPrepare** retornarão um erro.<br /><br /> Se a fonte de dados fornecer suporte sql nativo para instruções de atualização e exclusão posicionadas e o driver não simular cursores, SQL_SUCCESS é devolvido quando SQL_SC_UNIQUE é solicitada para SQL_SIMULATE_CURSOR. SQL_SUCCESS_WITH_INFO é devolvido se SQL_SC_TRY_UNIQUE ou SQL_SC_NON_UNIQUE for solicitado. Se a fonte de dados fornecer o nível de suporte SQL_SC_TRY_UNIQUE e o motorista não, SQL_SUCCESS é devolvido para SQL_SC_TRY_UNIQUE e SQL_SUCCESS_WITH_INFO é devolvido para SQL_SC_NON_UNIQUE.<br /><br /> Se o tipo de simulação do cursor especificado não for suportado pela fonte de dados, o driver substituirá um tipo de simulação diferente e devolverá o SQLSTATE 01S02 (valor da opção alterado). Para SQL_SC_UNIQUE, o motorista substitui, em ordem, SQL_SC_TRY_UNIQUE ou SQL_SC_NON_UNIQUE. Para SQL_SC_TRY_UNIQUE, o motorista substitui SQL_SC_NON_UNIQUE.<br /><br /> O padrão é SQL_SC_UNIQUE.<br /><br /> Para obter mais informações, consulte [Simular Atualização Posicionada e Excluir Declarações](../../../odbc/reference/develop-app/simulating-positioned-update-and-delete-statements.md).|  
|SQL_ATTR_USE_BOOKMARKS (ODBC 2.0)|Um valor SQLULEN que especifica se um aplicativo usará marcadores com um cursor:<br /><br /> SQL_UB_OFF = Desligado (o padrão)<br /><br /> SQL_UB_VARIABLE = Um aplicativo usará marcadores com um cursor, e o driver fornecerá marcadores de comprimento variável se forem suportados. SQL_UB_FIXED é preterido em ODBC *3.x*. Os aplicativos ODBC *3.x* devem sempre usar marcadores de comprimento variável, mesmo quando trabalham com drivers ODBC *2.x* (que suportavam apenas marcadores de 4 bytes e comprimento fixo). Isso porque um marcador de comprimento fixo é apenas um caso especial de um marcador de comprimento variável. Ao trabalhar com um driver ODBC *2.x,* o Driver Manager mapeia SQL_UB_VARIABLE para SQL_UB_FIXED.<br /><br /> Para usar marcadores com um cursor, o aplicativo deve especificar este atributo com o valor SQL_UB_VARIABLE antes de abrir o cursor.<br /><br /> Para obter mais informações, consulte [Marcadores de recuperação](../../../odbc/reference/develop-app/retrieving-bookmarks.md).|  
  
 [1] Essas funções só podem ser chamadas assíncronamente se o descritor for um descritor de implementação, não um descritor de aplicativo.  
  
 Consulte [a vinculação de coluna-wise](../../../odbc/reference/develop-app/column-wise-binding.md) e [a vinculação em termos de linha](../../../odbc/reference/develop-app/row-wise-binding.md).  
  
## <a name="related-functions"></a>Funções relacionadas  
  
|Para obter informações sobre|Consulte|  
|---------------------------|---------|  
|Cancelamento do processamento de declarações|[Função SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Retornando a configuração de um atributo de conexão|[Função SQLGetConnectAttr](../../../odbc/reference/syntax/sqlgetconnectattr-function.md)|  
|Retornando a configuração de um atributo de declaração|[Função SQLGetStmtAttr](../../../odbc/reference/syntax/sqlgetstmtattr-function.md)|  
|Definindo um atributo de conexão|[Função SQLSetConnectAttr](../../../odbc/reference/syntax/sqlsetconnectattr-function.md)|  
|Definindo um único campo do descritor|[Função SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md)|  
  
## <a name="see-also"></a>Consulte Também  
 [Referência da API oDBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Arquivos de cabeçalho ODBC](../../../odbc/reference/install/odbc-header-files.md)
