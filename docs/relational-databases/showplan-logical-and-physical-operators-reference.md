---
description: Referência de operadores físicos e lógicos de plano de execução
title: Referência de operadores físicos e lógicos do plano de execução
ms.custom: seo-dt-2019
ms.date: 10/12/2017
ms.prod: sql
ms.prod_service: database-engine, sql-database
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
f1_keywords:
- sql13.swb.showplan.leftouterjoin.f1
- sql13.swb.showplan.remotedelete.f1
- sql13.swb.showplan.parallelism.f1
- sql13.swb.showplan.indexspool.f1
- sql13.swb.showplan.result.f1
- sql13.swb.showplan.bitmapcreate.f1
- sql13.swb.showplan.remotescan.f1
- sql13.swb.showplan.union.f1
- sql13.swb.showplan.bitmap.f1
- sql13.swb.showplan.RIDLookup
- sql13.swb.showplan.innerjoin.f1
- sql13.swb.showplan.dynamic.f1
- sql13.swb.showplan.distributestreams.f1
- sql13.swb.showplan.clusteredindexdelete.f1
- sql13.swb.showplan.keylookup.f1
- sql13.swb.showplan.partialaggregate.f1
- sql13.swb.showplan.distinctsort.f1
- sql13.swb.showplan.collapse.f1
- sql13.swb.showplan.print.f1
- sql13.swb.showplan.crossjoin.f1
- sql13.swb.showplan.convert.f1
- sql13.swb.showplan.split.f1
- sql13.swb.showplan.top.f1
- sql13.swb.showplan.update.f1
- sql13.swb.showplan.keyset.f1
- sql13.swb.showplan.fetchquery.f1
- sql13.swb.showplan.mergejoin.f1
- sql13.swb.showplan.branchrepartition.f1
- sql13.swb.showplan.tableinsert.f1
- sql13.swb.showplan.clusteredindexseek.f1
- sql13.swb.showplan.indexupdate.f1
- sql13.swb.showplan.indexinsert.f1
- sql13.swb.showplan.clusteredindexupdate.f1
- sql13.swb.showplan.streamaggregate.f1
- sql13.swb.showplan.columnstoreindexdelete.f1
- sql13.swb.showplan.snapshot.f1
- sql13.swb.showplan.remotequery.f1
- sql13.swb.showplan.constantscan.f1
- sql13.swb.showplan.rank.f1
- sql13.swb.showplan.rightsemijoin.f1
- sql13.swb.showplan.delete.f1
- sql13.swb.showplan.sequence.f1
- sql13.swb.showplan.locate.f1
- sql13.swb.showplan.aggregate.f1
- sql13.swb.showplan.rightouterjoin.f1
- sql13.swb.showplan.columnstoreindexupdate.f1
- sql13.swb.showplan.clusteredindexinsert.f1
- sql13.swb.showplan.rowcountspool.f1
- sql13.swb.showplan.columnstoreindexscan.f1
- sql13.swb.showplan.leftantisemijoin.f1
- sql13.swb.showplan.sort.f1
- sql13.swb.showplan.leftsemijoin.f1
- sql13.swb.showplan.columnstoreindexinsert.f1
- sql13.swb.showplan.indexscan.f1
- sql13.swb.showplan.columnstoreindexmerge.f1
- sql13.swb.showplan.lazyspool.f1
- sql13.swb.showplan.rightantisemijoin.f1
- sql13.swb.showplan.bookmarklookup.f1
- sql13.swb.showplan.remoteinsert.f1
- sql13.swb.showplan.intrinsic.f1
- sql13.swb.showplan.arithmeticexpression.f1
- sql13.swb.showplan.populationquery.f1
- sql13.swb.showplan.filter.f1
- sql13.swb.showplan.if.f1
- sql13.swb.showplan.hashmatchteam.f1
- sql13.swb.showplan.tablevaluedfunction.f1
- sql13.swb.showplan.assign.f1
- sql13.swb.showplan.nestedloops.f1
- sql13.swb.showplan.buildhash.f1
- sql13.swb.showplan.mergeinterval.f1
- sql13.swb.showplan.hashmatch.f1
- sql13.swb.showplan.parametertablescan.f1
- sql13.swb.showplan.tablemerge.f1
- sql13.swb.showplan.switch.f1
- sql13.swb.showplan.sql.f1
- sql13.swb.showplan.repartitionstreams.f1
- sql13.swb.showplan.logrowscan.f1
- sql13.swb.showplan.assert.f1
- sql13.swb.showplan.computescalar.f1
- sql13.swb.showplan.broadcast.f1
- sql13.swb.showplan.indexseek.f1
- sql13.swb.showplan.gatherstreams.f1
- sql13.swb.showplan.remoteindexscan.f1
- sql13.swb.showplan.segment.f1
- sql13.swb.showplan.tableupdate.f1
- sql13.swb.showplan.clusteredindexscan.f1
- sql13.swb.showplan.cache.f1
- sql13.swb.showplan.spool.f1
- sql13.swb.showplan.indexdelete.f1
- sql13.swb.showplan.distinct.f1
- sql13.swb.showplan.deletedscan.f1
- sql13.swb.showplan.eagerspool.f1
- sql13.swb.showplan.hashmatchroot.f1
- sql13.swb.showplan.setfunction.f1
- sql13.swb.showplan.clusteredindexmerge.f1
- sql13.swb.showplan.flowdistinct.f1
- sql13.swb.showplan.tabledelete.f1
- sql13.swb.showplan.tablescan.f1
- sql13.swb.showplan.refreshquery.f1
- sql13.swb.showplan.tablespool.f1
- sql13.swb.showplan.insertedscan.f1
- sql13.swb.showplan.insert.f1
- sql13.swb.showplan.remoteindexseek.f1
- sql13.swb.showplan.fullouterjoin.f1
- sql13.swb.showplan.declare.f1
- sql13.swb.showplan.udx.f1
- sql13.swb.showplan.while.f1
- sql13.swb.showplan.remoteupdate.f1
- sql13.swb.showplan.concatenation.f1
- sql13.swb.showplan.computescalar
- sql13.swb.showplan.foreignkeyreferencescheck
helpviewer_keywords:
- execution plans [SQL Server], operators
- ActualRows attribute
- reading execution plan output
- ActualRewinds attribute
- ActualEndOfScans attribute
- query tuning [SQL Server]
- mapping operators [SQL Server]
- operators [Database Engine query tuning]
- logical operators [SQL Server], execution plans
- logical operators [SQL Server], listed
- physical operators [SQL Server]
- ActualRebinds attribute
- execution plans [SQL Server], reading output
ms.assetid: e43fd0fe-5ea7-4ffe-8d52-759ef6a7c361
author: rothja
ms.author: jroth
monikerRange: =azuresqldb-current||>=sql-server-2016||=sqlallproducts-allversions||>=sql-server-linux-2017||=azuresqldb-mi-current
ms.openlocfilehash: 93640502582b244c4b6e36473a087d84f53423c8
ms.sourcegitcommit: e700497f962e4c2274df16d9e651059b42ff1a10
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/17/2020
ms.locfileid: "88455489"
---
# <a name="showplan-logical-and-physical-operators-reference"></a>Referência de operadores físicos e lógicos de plano de execução
[!INCLUDE [SQL Server Azure SQL Database](../includes/applies-to-version/sql-asdb.md)]
  Os operadores descrevem como o [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] executa uma consulta ou uma instrução DML (Linguagem de Manipulação de Dados). O otimizador de consultas usa os operadores para criar um plano de consulta a fim de criar o resultado especificado na consulta ou para executar a operação especificada na instrução DML. O plano de consulta é uma árvore que consiste em operadores físicos. Você pode exibir o plano de consulta usando as instruções SET SHOWPLAN, as opções de plano de execução gráfica no [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]ou as classes de evento do Plano de Execução do SQL Server Profiler.  
  
 Os operadores são classificados como lógicos e físicos.  
  
 **Operadores lógicos**  
 Os operadores lógicos descrevem a operação algébrica relacional usada para processar uma instrução. Em outras palavras, operadores lógicos descrevem conceitualmente qual operação precisa ser executada.  
  
 **Operadores físicos**  
 Os operadores físicos implementam a operação descrita pelos operadores lógicos. Cada operador físico é um objeto ou uma rotina que executa uma operação. Por exemplo, alguns operadores físicos acessam colunas ou linhas de uma tabela, índice ou exibição. Outros operadores físicos executam outras operações como cálculos, agregações, verificações da integridade de dados ou junções. Os operadores físicos possuem custos associados.  
  
 Os operadores físicos iniciam, coletam dados e fecham. Especificamente, o operador físico pode responder às três chamadas de método abaixo:  
  
-   **Init()** : o método **Init()** faz com que um operador físico se inicialize e define quaisquer estruturas de dados necessárias. O operador físico pode receber muitas chamadas **Init()** ; entretanto, um operador físico costuma receber somente uma.  
  
-   **GetNext()** : o método **GetNext()** faz um operador físico obter a primeira linha de dados ou a subsequente. O operador físico pode receber zero ou muitas chamadas **GetNext()** .  
  
-   **Close()** : o método **Close()** faz um operador físico executar algumas operações de limpeza total e se desligar. Um operador físico só recebe uma chamada **Close()** .  
  
O método **GetNext ()** retorna uma linha de dados e o número de vezes que ele é chamado aparece como **ActualRows** na saída Showplan produzida ao usar `SET STATISTICS PROFILE ON` ou `SET STATISTICS XML ON`. Para obter mais informações sobre essas opções SET, veja [SET STATISTICS PROFILE &#40;Transact-SQL&#41;](../t-sql/statements/set-statistics-profile-transact-sql.md) e [SET STATISTICS XML &#40;Transact-SQL&#41;](../t-sql/statements/set-statistics-xml-transact-sql.md).  
  
Os contadores **ActualRebinds** e **ActualRewinds** exibidos na saída do Plano de Execução referem-se ao número de vezes que o método **Init()** é chamado. A menos que um operador esteja no lado interno de uma junção de loops aninhados, **ActualRebinds** será igual a um e **ActualRewinds** será igual a zero. Se um operador estiver no lado interno de uma junção de loop, a soma do número de reassociações e retrocessos deve ser igual ao número de linhas processadas no lado externo da junção. Uma reassociação significa que um ou mais dos parâmetros correlatos da junção se alterou e o lado interno deve ser reavaliado. Um retrocesso significa que nenhum dos parâmetros correlatos se alterou e o conjunto de resultados interno anterior pode ser usado novamente.  
  
**ActualRebinds** e **ActualRewinds** estão presentes na saída do Plano de Execução XML produzida usando a opção SET STATISTICS XML ON. Eles só são populados para os operadores **Nonclustered Index Spool**, **Remote Query**, **Row Count Spool**, **Sort**, **Table Spool**e **Table-valued Function** . **ActualRebinds** e **ActualRewinds** também podem ser populados para os operadores **Assert** e **Filter** quando o atributo **StartupExpression** é definido como TRUE.  
  
Quando **ActualRebinds** e **ActualRewinds** estiverem presentes em um Plano de Execução XML, serão comparáveis a **EstimateRebinds** e **EstimateRewinds**. Quando estiverem ausentes, o número estimado de linhas (**EstimateRows**) será comparável ao número de linhas real (**ActualRows**). Observe que a saída gráfica real do Plano de Execução exibe zeros para reassociações e retrocessos reais quando eles estão ausentes.  
  
Um contador relacionado, **ActualEndOfScans**, só está disponível quando a saída do Plano de Execução é produzida usando a opção SET STATISTICS XML ON. Sempre que um operador físico chega ao término de seu fluxo de dados, esse contador é incrementado em um. Um operador físico pode chegar ao término de seu fluxo de dados zero, uma ou mais vezes. Como com as reassociações e os retrocessos, o número de término de exames só poderá ser superior a um se o operador estiver no lado interno de uma junção de loop. O número de término de exames deveria ser inferior ou igual à soma do número de reassociações e retrocessos.  
  
## <a name="mapping-physical-and-logical-operators"></a>Mapeando operadores físicos e lógicos  
 O otimizador de consulta criará um plano de consulta no formato de árvore que consistirá em operadores lógicos. Após criar o plano, o otimizador de consulta escolherá o operador físico mais eficiente para cada operador lógico. O otimizador de consulta usa uma abordagem baseada em custos para determinar qual operador físico implementará um operador lógico.  
  
 Normalmente, uma operação lógica pode ser implementada por diversos operadores físicos. Em alguns casos raros, porém, um operador físico também pode implementar diversas operações lógicas.  
  
## <a name="operator-descriptions"></a>Descrições dos operadores  
 Esta seção contém descrições dos operadores lógicos e físicos.  

 > [!TIP]
 > Sempre que um determinado ícone do plano de execução gráfico tiver um círculo amarelo com duas setas da direita para a esquerda, isso significará uma execução em paralelo do operador. Para obter mais informações sobre paralelismo, confira o [Guia de arquitetura de threads e tarefas](../relational-databases/thread-and-task-architecture-guide.md#sql-server-task-scheduling).
  
|Ícone do plano de execução gráfica|Operador de plano de execução|Descrição|  
|-----------------------------------|-----------------------|-----------------|  
|![Ícone do operador Adaptive Join](../relational-databases/media/AdaptiveJoin.gif "Ícone do operador Adaptive Join")|**Junção Adaptável**|O operador de **Junção Adaptável** habilita que as opções de método de junção hash ou de junção de loop aninhado sejam adiadas até após a verificação da primeira entrada. O operador de **Junção Adaptável** é um operador físico. Para obter mais informações, confira [Noções básicas sobre junções adaptáveis](../relational-databases/performance/joins.md#adaptive). | 
|Nenhum|**Aggregate**|O operador **Aggregate** calcula uma expressão que contém MIN, MAX, SUM, COUNT ou AVG. O operador **Aggregate** pode ser um operador lógico ou um operador físico.| 
|![Ícone do operador Arithmetic expression](../relational-databases/media/arithmetic-expression-32x-2.gif "Ícone do operador Arithmetic expression")|**Arithmetic Expression**|O operador **Arithmetic Expression** computa um valor novo de valores existentes em uma linha. **Expressão Aritmética** não é usada no [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].| 
|Nenhum|**Async Concat**|O operador **Async Concat** só é usado em consultas remotas (consultas distribuídas). Ele tem *n* filhos e um nó pai. Normalmente, alguns dos filhos são computadores remotos que participam de uma consulta distribuída. O **Async Concat** emite `open()` chamadas simultaneamente a todos os filhos e aplica um bitmap para cada filho. Para cada bit que é um 1, **Async Concat** envia linhas de saída para o nó pai sob demanda.| 
|![Ícone do operador Assert](../relational-databases/media/assert-32x.gif "Ícone do operador Assert")|**Assert**|O operador **Assert** verifica uma condição. Por exemplo, ele valida integridade referencial ou assegura que uma subconsulta escalar retorne uma linha. Para cada linha de entrada, o operador **Assert** avalia a expressão na coluna **Argumento** do plano de execução. Se essa expressão for avaliada como NULL, a linha será passada pelo operador **Assert** e a execução de consulta continuará. Se essa expressão for avaliada como um valor não nulo, será gerado um erro apropriado. O operador **Assert** é um operador físico.| 
|![Ícone do elemento de linguagem Assign](../relational-databases/media/assign-32.gif "Ícone do elemento de linguagem Assign")|**Assign**|O operador **Assign** atribui o valor de uma expressão ou constante a um variável. **Assign** é um elemento de linguagem.| 
|![Ícone do operador Bitmap](../relational-databases/media/bitmap-32x.gif "Ícone do operador Bitmap")|**Bitmap Create**|O operador **Bitmap Create** aparece na saída do plano de execução onde os bitmaps são criados. **Bitmap Create** é um operador lógico.| 
|![Ícone do operador Bitmap](../relational-databases/media/bitmap-32x.gif "Ícone do operador Bitmap")|**Bitmap**|[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] usa o operador **Bitmap** para implementar filtro de bitmap em planos de consulta paralelos. O filtro de bitmap acelera a execução de consulta eliminando linhas com valores de chave que não podem produzir nenhum relatório de junção antes de transmitir as linhas por outro operador como o operador **Parallelism** . Um filtro de bitmap usa uma representação compacta de um conjunto de valores de uma tabela em uma parte da árvore de operador de uma segunda tabela em outra parte da árvore. Com a remoção de linhas desnecessárias previamente na consulta, os operadores subsequentes têm menos linhas para trabalhar e o desempenho geral da consulta melhora. O otimizador de consulta determina quando um bitmap é seletivo o bastante para ser útil e em quais operadores o filtro é aplicado. **Bitmap** é um operador físico.| 
|![Ícone do operador Bookmark lookup](../relational-databases/media/bookmark-lookup-32x.gif "Ícone do operador Bookmark lookup")|**Bookmark Lookup**|O operador **Bookmark Lookup** usa um indicador (ID da fila ou chave de clustering) para pesquisar a linha correspondente na tabela ou índice clusterizado. A coluna **Argument** contém o rótulo do indicador usado para procurar a linha na tabela ou índice clusterizado. A coluna **Argument** também contém o nome da tabela ou índice clusterizado no qual a linha é procurada. Se a cláusula WITH PREFETCH aparecer na coluna **Argument** , o processador de consulta determinará que convém usar a pré-busca assíncrona (read-ahead) ao procurar indicadores na tabela ou índice clusterizado.<br /><br /> Começando pelo [!INCLUDE[ssVersion2005](../includes/ssversion2005-md.md)], o **Bookmark Lookup** não é usado. Em vez disso, **Key Lookup** e **RID Lookup** fornecem funcionalidade de pesquisa de indicador.| 
|Nenhum|**Branch Repartition**|Às vezes, em um plano de consulta paralelo, há regiões conceituais de iteradores. Todos os iteradores dentro de tal região podem ser executados por threads paralelos. As próprias regiões devem ser executadas em série. Alguns dos iteradores **Parallelism** em uma região individual são chamados **Branch Repartition**. O iterador **Parallelism** no limite dessas duas regiões é chamado **Segment Repartition**. **Branch Repartition** e **Segment Repartition** são operadores lógicos.| 
|Nenhum|**Broadcast**|**Broadcast** tem um nó filho e *n* nós pai. **Broadcast** envia suas linhas de entrada para vários consumidores sob demanda. Cada consumidor adquire todas as linhas. Por exemplo, se todos os consumidores representarem lados de criação de uma junção hash, então serão criadas *n* cópias das tabelas de hash.| 
|![Ícone do operador Build hash](../relational-databases/media/build-hash.gif "Ícone do operador Build hash")|**Build Hash**|Indica a criação de uma tabela de hash de lote para um índice columnstore xVelocity de memória otimizada.| 
|Nenhum|**Cache**|O**Cache** é uma versão especializada do operador **Spool** . Ele armazena somente uma linha de dados. O**Cache** é um operador lógico. O**Cache** não é usado no [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].| 
|![Ícone do operador Clustered index delete](../relational-databases/media/clustered-index-delete-32x.gif "Ícone do operador Clustered index delete")|**Clustered Index Delete**|O operador **Clustered Index Delete** exclui linhas do índice clusterizado especificado na coluna Argumento do plano de execução da consulta. Se um predicado WHERE:() estiver presente na coluna Argument, somente as linhas que atenderem ao predicado serão excluídas.**Clustered Index Delete** é um operador físico.| 
|![Ícone do operador Clustered index insert](../relational-databases/media/clustered-index-insert-32x.gif "Ícone do operador Clustered index insert")|**Clustered Index Insert**|O operador de plano de execução **Clustered Index Insert** insere linhas de sua entrada no índice clusterizado especificado na coluna Argument. A coluna Argument também contém um predicado SET:(), que indica o valor para o qual cada coluna está definida. Se **Clustered Index Insert** não tiver nenhum filho para valores de inserção, a linha inserida será extraída do próprio operador **Insert** .**Clustered Index Insert** é um operador físico.| 
|![Operador Clustered index merge](../relational-databases/media/clustered-index-merge-32x.gif "Operador Clustered index merge")|**Clustered Index Merge**|O operador **Clustered Index Merge** aplica um fluxo de mesclagem de dados a um índice clusterizado. O operador exclui, atualiza ou insere linhas do índice clusterizado especificado na coluna **Argument** do operador. A operação real executada depende do valor de runtime da coluna **ACTION** especificada na coluna **Argument** do operador. **Clustered Index Merge** é um operador físico.| 
|![Ícone do operador Clustered index scan](../relational-databases/media/clustered-index-scan-32x.gif "Ícone do operador Clustered index scan")|**Clustered Index Scan**|O operador **Clustered Index Scan** examina as linhas do índice clusterizado especificado na coluna Argument do plano de execução da consulta. Quando houver um predicado opcional WHERE:(), somente as linhas que atenderem ao predicado serão retornadas. Se a coluna Argument apresentar a cláusula ORDERED, o processador de consulta solicitou que a saída das linhas seja retornada na ordem em que o índice clusterizado as classificou. Se a cláusula ORDERED não estiver presente, o mecanismo de armazenamento examinará o índice em modo ótimo, sem necessariamente classificar a saída. **Clustered Index Scan** é um operador lógico e físico.| 
|![Ícone do operador Clustered index seek](../relational-databases/media/clustered-index-seek-32x.gif "Ícone do operador Clustered index seek")|**Clustered Index Seek**|O operador **Clustered Index Seek** usa a habilidade de busca de índices para recuperar linhas de um índice cluster. A coluna **Argument** contém o nome do índice clusterizado que está sendo usado e o predicado SEEK:(). O mecanismo de armazenamento usa o índice para processar somente as linhas que satisfazem esse predicado SEEK:(). Ele pode incluir também um predicado WHERE:(), onde o mecanismo de armazenamento avaliará em relação a todas as linhas que satisfizerem o predicado SEEK:(), mas isso é opcional e não usa índices para executar esse processo.<br /><br /> Se a coluna **Argumento** contiver a cláusula ORDERED, o processador de consulta determinou que as linhas fossem retornadas na ordem em que o índice clusterizado as classificou. Se a cláusula ORDERED não estiver presente, o mecanismo de armazenamento pesquisará o índice em modo ótimo, sem necessariamente classificar a saída. Permitir que a saída retenha sua ordenação pode ser menos eficiente do que produzir saída não classificada. Quando a palavra-chave LOOKUP aparecer, então uma consulta de marcador está sendo executada. No [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] e em versões posteriores, o operador **Key Lookup** fornece a funcionalidade de consulta de marcador. **Clustered Index Seek** é um operador lógico e físico.| 
|![Ícone do operador Clustered index update](../relational-databases/media/clustered-index-update-32x.gif "Ícone do operador Clustered index update")|**Clustered Index Update**|O operador **Clustered Index Update** atualiza as linhas de entrada no índice clusterizado especificado na coluna **Argument** . Se um predicado WHERE:() estiver presente, somente as linhas que satisfazem esse predicado serão atualizadas. Se um predicado SET:() estiver presente, cada coluna atualizada será definida com esse valor. Se um predicado DEFINE: () está presente, serão listados os valores que esse operador definir. Esses valores podem ser referenciados na cláusula SET ou em outro lugar dentro desse operador e em outro lugar dentro dessa consulta. **Clustered Index Update** é um operador lógico e físico.| 
|![Ícone do operador Collapse](../relational-databases/media/collapse-32x.gif "Ícone do operador Collapse")|**Recolher**|O operador **Collapse** otimiza processamento de atualização. Quando uma atualização é executada, ela pode ser dividida (usando o operador **Split** ) em uma exclusão e uma entrada. A coluna **Argument** contém uma cláusula GROUP BY:() que especifica uma lista de colunas de chave. Se o processador de consultas encontrar linhas adjacentes que incluem e inserem os mesmos valores de chave, ele substituirá essas operações separadas por uma operação de atualização única e mais eficiente. **Collapse** é um operador lógico e físico.| 
|![Verificação de Índice Columnstore](../relational-databases/media/columnstoreindexscan.gif "Verificação de Índice Columnstore")|**Verificação de Índice Columnstore**|O operador **Columnstore Index Scan** examina o índice columnstore especificado na coluna **Argument** do plano de execução da consulta.| 
|![Ícone do operador Compute scalar](../relational-databases/media/compute-scalar-32x.gif "Ícone do operador Compute scalar")|**Compute Scalar**|O operador **Compute Scalar** avalia uma expressão para produzir um valor escalar computado. Isso pode ser retornado ao usuário, ter referência em outro lugar na consulta, ou ambos. Um exemplo de ambos está em um predicado de filtro ou predicado de junção. O**Compute Scalar** é um operador lógico e físico.<br /><br /> Operadores**Compute Escalar** que aparecem em planos de execução gerados por SET STATISTICS XML podem não conter o elemento **RunTimeInformation** . Em planos de execução gráficos, **Linhas Reais**, **Religações Reais**e **Retrocessos Reais** podem estar ausentes na janela **Propriedades** quando a opção **Incluir Plano de Execução Real** estiver selecionada em [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]. Quando isto acontece, significa que, embora os operadores tenham sido usados no plano de consulta compilado, o trabalho foi executado por outros operadores no plano de consulta de tempo de execução. Observe também que o número de execuções na saída de plano de execução gerada por SET STATISTICS PROFILE é equivalente à soma de reassociações e retrocessos em planos de execução gerados por SET STATISTICS XML.| 
|![Ícone do operador Concatenation](../relational-databases/media/concatenation-32x.gif "Ícone do operador Concatenation")|**Concatenation**|O operador **Concatenation** verifica várias entradas, retornando cada linha verificada. **Concatenation** normalmente é usado para implementar a construção UNION ALL [!INCLUDE[tsql](../includes/tsql-md.md)] . O operador físico **Concatenation** tem duas ou mais entradas e uma saída. Concatenation copia linhas do primeiro fluxo de entrada ao fluxo de saída e repete essa operação para cada fluxo de entrada adicional. **Concatenation** é um operador lógico e físico.| 
|![Ícone do operador Constant scan](../relational-databases/media/constant-scan-32x.gif "Ícone do operador Constant scan")|**Constant Scan**|O operador **Constant Scan** introduz uma ou mais linhas constantes em uma consulta. Um operador **Compute Scalar** é frequentemente usado após uma **Constant Scan** para acrescentar colunas a uma linha produzida pelo operador **Constant Scan** .| 
|![Ícone do elemento de linguagem Convert (mecanismo de banco de dados)](../relational-databases/media/convert-32x.gif "Ícone do elemento de linguagem Convert (mecanismo de banco de dados)")|**Converter**|O operador **Convert** converte um tipo de dados escalar em outro. **Convert** é um elemento de linguagem.| 
|Nenhum|**Cross Join**|O operador **Cross Join** une cada linha da primeira entrada (superior) a cada linha da segunda entrada (inferior). **Cross Join** é um operador lógico.| 
|Nenhum|**Cursor**|Os operadores lógicos e físicos **Cursor** são usados para descrever como é executada uma consulta ou atualização que envolva operações de cursor. Os operadores físicos descrevem o algoritmo de implementação físico usado para processar o cursor; por exemplo, usando um cursor controlado por conjunto de chaves. Cada etapa na execução de um cursor envolve um operador físico. Os operadores lógicos descrevem uma propriedade do cursor, como quando o cursor é somente leitura.<br /><br /> Operadores lógicos incluem Asynchronous, Optimistic, Primary, Read Only, Scroll Locks, Secondary e Synchronous.<br /><br /> Operadores físicos incluem Dynamic, Fetch Query, Keyset, Population Query, Refresh Query e Snapshot.| 
|![Ícone do operador de cursor Cursor catchall](../relational-databases/media/cursor-catch-all.gif "Ícone do operador de cursor Cursor catchall")|**catchall**|O ícone catchall é exibido quando a lógica que produz planos de execução gráficos não puder encontrar um ícone viável para o iterador. O ícone catchall não indica necessariamente uma condição de erro. Há três ícones catchall: azul (para iteradores), laranja (para cursores) e verde (para elementos de linguagem [!INCLUDE[tsql](../includes/tsql-md.md)] ).| 
|![Ícone do elemento de linguagem Declare](../relational-databases/media/declare-32x.gif "Ícone do elemento de linguagem Declare")|**Declare**|O operador **Declare** aloca uma variável local no plano de consulta. **Declare** é um elemento de linguagem.| 
|![Ícone do operador Delete (mecanismo de banco de dados)](../relational-databases/media/delete-32x.gif "Ícone do operador Delete (mecanismo de banco de dados)")|**Delete (excluir)**|O operador **Delete** efetua a exclusão em linhas de objeto que atendem ao predicado opcional na coluna **Argumento** .| 
|![Ícone do operador Delete scan](../relational-databases/media/delete-scan-32x.gif "Ícone do operador Delete scan")|**Deleted Scan**|O operador **Deleted Scan** examina a tabela excluída em um gatilho.| 
|Nenhum|**Distinct Sort**|O operador lógico **Distinct Sort** verifica a entrada, removendo duplicatas e fazendo classificação pelas colunas especificadas no predicado DISTINCT ORDER BY:() da coluna **Argument** . **Distinct Sort** é um operador lógico.| 
|Nenhum|**Distinct**|O operador **Distinct** remove duplicatas de um conjunto de linhas ou de uma coleção de valores. **Distinct** é um operador lógico.| 
|![Ícone do operador de paralelismo Distribute streams](../relational-databases/media/parallelism-distribute-stream.gif "Ícone do operador de paralelismo Distribute streams")|**Distribute Streams**|O operador **Distribute Streams** só é usado em planos de consulta paralelos. O operador **Distribute Streams** leva um fluxo de entrada simples de registros e produz fluxos de saída múltiplos. O conteúdo do registro e o formato não são alterados. Cada registro do fluxo de entrada aparece em um dos fluxos de saída. Este operador preserva automaticamente a ordem relativa dos registros de entrada nos fluxos de saída. Normalmente, são usadas operações de hash para decidir a qual fluxo de saída pertence um determinado registro de entrada.<br /><br /> Se a saída for particionada, a coluna **Argument** conterá um predicado PARTITION COLUMNS:() e as colunas de particionamento. **Distribute Streams** é um operador lógico| 
|![Ícone do operador de cursor Dynamic](../relational-databases/media/dynamic-32x.gif "Ícone do operador de cursor Dynamic")|**Dinâmicos**|O operador **Dynamic** usa um cursor que pode ver todas as alterações feitas por outros.| 
|![Ícone do operador de cursor Fetch query](../relational-databases/media/fetch-query-32x.gif "Ícone do operador de cursor Fetch query")|**Fetch Query**|O operador **Fetch Query** recupera linhas quando é feita uma busca em um cursor.| 
|![Ícone do operador Filter (mecanismo de banco de dados)](../relational-databases/media/filter-32x.gif "Ícone do operador Filter (mecanismo de banco de dados)")|**Filter**|O operador **Filter** examina a entrada, retornando apenas as linhas que satisfazem a expressão de filtro (predicado) que aparece na coluna **Argument** .| 
|Nenhum|**Flow Distinct**|O operador lógico **Flow Distinct** examina a entrada, removendo duplicatas. Enquanto o operador **Distinct** consome toda a entrada antes de produzir qualquer saída, o operador **FlowDistinct** retorna cada linha como foi obtida da entrada (a menos que a fila seja uma duplicata: nesse caso ela é descartada).| 
|![Ícone do operador Foreign key references check](../relational-databases/media/fk-references-32x.gif "Ícone do operador Foreign key references check")|**Verificação de Referências de Chave Estrangeira**|O operador **Verificação de Referências de Chave Estrangeira** executa verificações de integridade referencial no local, comparando a linha modificada com as linhas nas tabelas de referência para verificar se a modificação não afetará a integridade referencial. O operador **Verificação de Referências de Chave Estrangeira** é usado quando mais de 253 referências de chave estrangeira existem na mesma chave primária ou exclusiva. **Verificação de Referências de Chave Estrangeira** é um operador lógico e físico.| 
|Nenhum|**Full Outer Join**|O operador lógico **Full Outer Join** retorna cada linha que satisfaz o predicado de junção da primeira entrada (parte superior) associada a cada linha da segunda entrada (parte inferior). Ele também retorna linhas:<br /><br /> \- Da primeira entrada que não teve nenhuma correspondência na segunda entrada.<br /><br /> \- Da segunda entrada que não teve nenhuma correspondência na primeira entrada.<br /><br /> A entrada que não contém os valores correspondentes é retornada como um valor nulo. **Full Outer Join** é um operador lógico.| 
|![Ícone do operador de paralelismo Gather streams](../relational-databases/media/parallelism-32x.gif "Ícone do operador de paralelismo Gather streams")|**Gather Streams**|O operador **Gather Streams** só é usado em planos de consulta paralelos. O operador **Gather Streams** consome vários fluxos de entrada e produz um único fluxo de saída de registros ao combinar os fluxos de entrada. O conteúdo do registro e o formato não são alterados. Se este operador for preservador da ordem, todos os fluxos de entrada deverão ser ordenados. Se a saída for ordenada, a coluna **Argument** conterá um predicado ORDER BY:() e os nomes das colunas que estão sendo ordenadas. **Gather Streams** é um operador lógico.| 
|![Ícone do operador Hash match](../relational-databases/media/hash-match-32x.gif "Ícone do operador Hash match")|**Hash Match**|O operador **Hash Match** cria uma tabela de hash computando um valor de hash para cada linha da entrada criada. Um predicado HASH:() com uma lista de colunas usadas para criar um valor de hash aparece na coluna **Argument** . Então, para cada fila de sondagem (conforme aplicável), ela computa um valor de hash (usando a mesma função de hash) e procura correspondências na tabela de hash. Se um predicado residual estiver presente (identificado por RESIDUAL:() na coluna **Argument** ), esse predicado também deverá ser atendido para que as linhas sejam consideradas uma correspondência. O comportamento depende da operação lógica que está sendo executada:<br /><br /> \- Para qualquer junção, use a primeira entrada (superior) para criar a tabela de hash e a segunda (inferior) para sondar a tabela de hash. As correspondências de saída (ou não correspondências) conforme determinadas pelo tipo de junção. Se várias junções usam a mesma coluna de junção, essas operações serão agrupadas em uma equipe de hash.<br /><br /> \- Para os operadores distintos ou de agregação, use a entrada para criar a tabela de hash (removendo duplicatas e computando quaisquer expressões de agregação). Quando a tabela de hash for criada, verifique a tabela e saída de todas as entradas.<br /><br /> \- Para o operador de união, use a primeira entrada para criar a tabela de hash (removendo duplicatas). Use a segunda entrada (que não deve ter uma duplicata) para sondar a tabela de hash, retornando todas linhas sem correspondência e, então, verifique a tabela de hash e retorne todas as entradas.<br />**Hash Match** é um operador físico. Para obter mais informações, confira [Noções básicas sobre junções hash](../relational-databases/performance/joins.md#hash).| 
|![Ícone do elemento de linguagem If](../relational-databases/media/if-32x.gif "Ícone do elemento de linguagem If")|**If**|O operador **If** executa processamento condicional com base em uma expressão. **If** é um elemento de linguagem.| 
|Nenhum|**Inner Join**|O operador lógico **Inner Join** retorna cada linha que satisfaz a junção da primeira entrada (superior) com a segunda entrada (inferior).| 
|![Ícone do operador Insert (mecanismo de banco de dados)](../relational-databases/media/insert-32x.gif "Ícone do operador Insert (mecanismo de banco de dados)")|**Inserção**|O operador lógico **Insert** insere cada linha de sua entrada no objeto especificado na coluna **Argument** . O operador físico é o operador **Table Insert**, **Index Insert**ou **Clustered Index Insert** .| 
|![Ícone do operador Inserted scan](../relational-databases/media/inserted-scan-32x.gif "Ícone do operador Inserted scan")|**Inserted Scan**|O operador **Inserted Scan** verifica a tabela **inserida** . O**Inserted Scan** é um operador lógico e físico.| 
|![Ícone do elemento de linguagem Intrinsic](../relational-databases/media/intrinsic-32x.gif "Ícone do elemento de linguagem Intrinsic")|**Intrinsic**|O operador **Intrinsic** invoca uma função [!INCLUDE[tsql](../includes/tsql-md.md)] interna. **Intrinsic** é um elemento de linguagem.| 
|![Ícone do operador Iterator catchall](../relational-databases/media/iterator-catch-all.gif "Ícone do operador Iterator catchall")|**Iterador**|O ícone catchall **Iterator** é exibido quando um ícone adequado para o iterador não é encontrado pela lógica que produz planos de execução gráfica. O ícone catchall não indica necessariamente uma condição de erro. Há três ícones catchall: azul (para iteradores), laranja (para cursores) e verde (para construções de linguagem do [!INCLUDE[tsql](../includes/tsql-md.md)] ).| 
|![Ícone do operador Bookmark lookup](../relational-databases/media/bookmark-lookup-32x.gif "Ícone do operador Bookmark lookup")|**Key Lookup**|O operador **Key Lookup** é uma pesquisa de indicadores em uma tabela com um índice clusterizado. A coluna **Argumento** contém o nome do índice clusterizado e a chave de clusterização usada para procurar a linha no índice clusterizado. **Key Lookup** é sempre acompanhada por um operador **Loops** . Se a cláusula WITH PREFETCH aparecer na coluna **Argument** , o processador de consultas determinará que o ideal é usar a pré-busca assíncrona (read-ahead) ao observar marcadores no índice clusterizado.<br /><br /> O uso de um operador **Key Lookup** em um plano de consulta indica que a consulta pode se beneficiar de ajuste de desempenho. Por exemplo, o desempenho da consulta pode ser melhorado adicionando-se um índice de cobertura.| 
|![Ícone do operador de cursor Keyset](../relational-databases/media/keyset-32x.gif "Ícone do operador de cursor Keyset")|**Keyset**|O operador **Keyset** usa um cursor que pode visualizar atualizações, mas não inserções feitas por outros.| 
|![Ícone do elemento de linguagem catchall](../relational-databases/media/language-construct-catch-all.gif "Ícone do elemento de linguagem catchall")|**Elemento Language**|O ícone catchall **Language Element** é exibido quando um ícone adequado para o iterador não é encontrado pela lógica que produz planos de execução gráfica. O ícone catchall não indica necessariamente uma condição de erro. Há três ícones catchall: azul (para iteradores), laranja (para cursores) e verde (para construções de linguagem do [!INCLUDE[tsql](../includes/tsql-md.md)] ).| 
|Nenhum|**Left Anti Semi Join**|O operador **Left Anti Semi Join** retorna cada linha da primeira entrada (parte superior) quando não existe uma linha correspondente na segunda entrada (parte inferior). Se não houver nenhum predicado de junção na coluna **Argument** , cada linha será uma linha correspondente. **Left Anti Semi Join** é um operador lógico.| 
|Nenhum|**Left Outer Join**|O operador **Left Outer Join** retorna cada linha que satisfaz a junção da primeira entrada (parte superior) com a segunda entrada (parte inferior). Ele também retorna linhas da primeira entrada que não teve linhas correspondentes na segunda entrada. As linhas não correspondentes na segunda entrada são retornadas como valores nulos. Se não houver nenhum predicado de junção na coluna **Argument** , cada linha será uma linha correspondente. **Left Outer Join** é um operador lógico.| 
|Nenhum|**Left Semi Join**|O operador **Left Semi Join** retornará todas as linhas da segunda entrada (inferior) quando existir uma linha correspondente na primeira entrada (superior). Se não houver nenhum predicado de junção na coluna **Argument** , cada linha será uma linha correspondente. **Left Semi Join** é um operador lógico.| 
|![Ícone do operador Log row scan](../relational-databases/media/log-row-scan-32x.gif "Ícone do operador Log row scan")|**Log Row Scan**|O operador **Log Row Scan** examina o log de transações. **Log Row Scan** é um operador lógico e físico.| 
|![Ícone do operador Merge interval](../relational-databases/media/merge-interval-32x.gif "Ícone do operador Merge interval")|**Merge Interval**|O operador **Merge Interval** mescla vários intervalos (com sobreposição potencial) para produzir intervalos mínimo, não sobrepostos, usados para buscar entradas de índice. Esse operador aparece geralmente sobre um ou mais operadores **Compute Scalar** sobre operadores **Constant Scan** que constroem os intervalos (representados como colunas em uma linha) que esse operador mescla. **Merge Interval** é um operador lógico e físico.| 
|![Ícone do operador Merge join](../relational-databases/media/merge-join-32x.gif "Ícone do operador Merge join")|**Junção de Mesclagem**|O operador **Merge Join** executa a inner join, left outer join, left semi join, left anti semi join, right outer join, right semi join, right anti semi join e operações lógicas de união.<br /><br /> Na coluna **Argument** , o operador **Merge Join** contém um predicado MERGE:() se a operação estiver executando uma junção de um para muitos, ou um predicado MANY-TO-MANY MERGE:() se a operação estiver executando uma junção de muitos para muitos. A coluna **Argument** também inclui uma lista de colunas separada por vírgula usada para executar a operação. O operador **Merge Join** requer duas entradas classificadas em suas respectivas colunas, possivelmente inserindo operações de classificação explícitas no plano de consulta. A junção de mesclagem é particularmente eficaz se não for exigida uma classificação explícita, por exemplo, se houver um índice da árvore B adequado no banco de dados, ou se a ordem de classificação puder ser explorada para diversas operações, como uma junção de mesclagem e um agrupamento com acúmulo. **Merge Join** é um operador físico. Para obter mais informações, confira [Noções básicas sobre junções de mesclagem](../relational-databases/performance/joins.md#merge).| 
|![Ícone do operador Nested loops](../relational-databases/media/nested-loops-32x.gif "Ícone do operador Nested loops")|**Nested Loops**|O operador **Nested Loops** executa operações lógicas de junção interna, junção externa esquerda, left semi join e left anti semi join. As junções de loops aninhados executam uma pesquisa na tabela interna para cada linha da tabela externa, normalmente usando um índice. O processador de consultas decide, com base em custos previstos, se classificará a entrada externa para aprimorar a localidade das pesquisas no índice da entrada interna. Qualquer linha que atende ao predicado (opcional) na coluna **Argument** é retornada como aplicável, com base na operação lógica em execução. Quando o atributo OPTIMIZED é definido como **True**, isso significa que Loops aninhados otimizados (ou Classificação em lote) são usados. **Nested Loops** é um operador físico. Para obter mais informações, consulte [Noções básicas sobre junções de loops aninhados](../relational-databases/performance/joins.md#nested_loops).| 
|![Ícone do operador Nonclustered index delete](../relational-databases/media/nonclust-index-delete-32x.gif "Ícone do operador Nonclustered index delete")|**Nonclustered Index Delete**|O operador **Nonclustered Index Delete** exclui linhas de entrada do índice não cluster especificado na coluna **Argument** . **Nonclustered Index Delete** é um operador físico.| 
|![Ícone do operador Nonclustered index insert](../relational-databases/media/nonclust-index-insert-32x.gif "Ícone do operador Nonclustered index insert")|**Index Insert**|O operador **Index Insert** insere linhas de sua entrada no índice não clusterizado especificado na coluna **Argument** . A coluna **Argument** também contém um predicado SET:(), que indica o valor para o qual cada coluna está definida. **Index Insert** é um operador físico.| 
|![Ícone do operador Nonclustered index scan](../relational-databases/media/nonclustered-index-scan-32x.gif "Ícone do operador Nonclustered index scan")|**Index Scan**|O operador **Index Scan** recupera todas as linhas do índice não clusterizado especificado na coluna **Argument** . Se um predicado opcional WHERE:() aparecer na coluna **Argument** , somente as linhas que atenderem ao predicado serão retornadas. **Index Scan** é um operador lógico e físico.| 
|![Ícone do operador Nonclustered index seek](../relational-databases/media/index-seek-32x.gif "Ícone do operador Nonclustered index seek")|**Index Seek**|O operador **Index Seek** usa a capacidade de busca de índices para recuperar linhas de um índice não clusterizado. A coluna **Argument** contém o nome do índice não clusterizado usado. Também contém o predicado SEEK:(). O mecanismo de armazenamento usa o índice para processar somente as linhas que atendem ao predicado SEEK:(). Ele pode incluir opcionalmente um predicado WHERE:(), que o mecanismo de armazenamento avaliará em relação a todas as linhas que atenderem ao predicado SEEK:() (não usa os índices para fazer isso). Se a coluna **Argument** contém a cláusula ORDERED, o processador de consulta determinou que as linhas fossem retornadas na ordem em que o índice não clusterizado as classificou. Se a cláusula ORDERED não estiver presente, o mecanismo de armazenamento pesquisará o índice no modo ideal (o que não garante que a saída será classificada). Permitir que a saída retenha sua ordenação pode ser menos eficiente que produzir saída não classificada. **Index Seek** é um operador lógico e físico.| 
|![Ícone do operador Nonclustered index spool](../relational-databases/media/index-spool-32x.gif "Ícone do operador Nonclustered index spool")|**Index Spool**|O operador físico **Index Spool** contém um predicado SEEK:() na coluna **Argument** . O operador **Index Spool** examina suas linhas de entrada, colocando uma cópia de cada linha em um arquivo spool oculto (armazenado no banco de dados **tempdb** que existe somente durante o tempo de vida da consulta) e cria um índice não clusterizado nas linhas. Isto permite que você use o recurso de busca de índices para produzir somente as linhas que correspondem ao predicado SEEK: (). Se for feito o retrocesso do operador (por exemplo, por um operador **Nested Loops** ) sem que haja necessidade de reassociação, serão usados os dados em spool em vez de um novo exame da entrada.| 
|![Ícone do operador Nonclustered index update](../relational-databases/media/nonclust-index-update-32x.gif "Ícone do operador Nonclustered index update")|**Nonclustered Index Update**|O operador físico **Nonclustered Index Update** atualiza linhas de sua entrada no índice não clusterizado especificado na coluna **Argument** . Se um predicado SET:() estiver presente, cada coluna atualizada será definida com esse valor. **Nonclustered Index Update** é um operador físico.| 
|![Ícone do operador Online index insert](../relational-databases/media/online-index-32x.gif "Ícone do operador Online index insert")|**Online Index Insert**|O operador físico **Online Index Insert** indica que uma operação de criação, alteração ou remoção de índice é executada online. Ou seja, os dados da tabela subjacente permanecem disponíveis para usuários durante a operação de índice.| 
|Nenhum|**Parallelism**|<a name="exchange"></a> O operador **Parallelism** (ou iterador de troca) executa operações lógicas de fluxos de distribuição, fluxos de coleta e fluxos de repartição. As colunas **Argument** podem conter um predicado PARTITION COLUMNS:() com uma lista separada por vírgula das colunas que estão sendo particionadas. As colunas **Argument** também podem conter um predicado ORDER BY:(), listando as colunas para preservar a ordem de classificação durante o particionamento. **Parallelism** é um operador físico. Para saber mais sobre o operador Parallelism, confira a [série de blog de Craig Freedman](https://docs.microsoft.com/archive/blogs/craigfr/the-parallelism-operator-aka-exchange).<br /><br />**Observação:** se uma consulta tiver sido compilada como uma consulta paralela, mas no tempo de execução for executada como consulta serial, a saída do Plano de Execução gerada por SET STATISTICS XML ou pela opção **Incluir Plano de Execução Real** no [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] não incluirá o elemento **RunTimeInformation** para o operador **Parallelism**. Na saída SET STATISTICS PROFILE, as contagens reais de linha e número real de execuções exibirão zeros para o operador **Parallelism** . Quando uma dessas condições ocorre, significa que o operador **Parallelism** só foi usado durante a compilação da consulta e não no plano de consulta em tempo de execução. Observe que às vezes os planos de consulta paralelos serão executados em série, se houver uma carga simultânea grande no servidor.| 
|![Ícone do operador Parameter table scan](../relational-databases/media/parameter-table-scan-32x.gif "Ícone do operador Parameter table scan")|**Parameter Table Scan**|O operador **Parameter Table Scan** examina uma tabela que está atuando como um parâmetro na consulta atual. Normalmente, isto é usado para consultas INSERT dentro de um procedimento armazenado. **Parameter Table Scan** é um operador lógico e físico.| 
|Nenhum|**Partial Aggregate**|**Agregação parcial** é usada em planos paralelos. Aplica uma função de agregação para tantas linhas de entrada quanto possíveis de forma que gravar em disco (conhecido como "derramamento") não é necessário. **Hash Match** é o único operador físico (iterator) que implementa agregação de partição. **Agregação parcial** é um operador lógico.| 
|![Ícone do operador de cursor Population query](../relational-databases/media/poulation-query-32x.gif "Ícone do operador de cursor Population query")|**Population Query**|O operador **Population Query** popula a tabela de trabalho de um cursor quando o cursor é aberto.| 
|![Ícone do operador de cursor Refresh query](../relational-databases/media/refresh-query-32x.gif "Ícone do operador de cursor Refresh query")|**Refresh Query**|O operador **Refresh Query** busca dados atuais para linhas do buffer de busca.| 
|![Ícone do operador Remote delete](../relational-databases/media/remote-delete-32x.gif "Ícone do operador Remote delete")|**Remote Delete**|O operador **Remote Delete** exclui as linhas de entrada a partir de um objeto remoto. **Remote Delete** é um operador lógico e físico.| 
|![Operador remote index seek showplan](../relational-databases/media/remote-index-scan-32x.gif "operador remote index seek showplan")|**Remote Index Scan**|O operador **Remote Index Scan** examina o índice remoto especificado na coluna Argument. **Verificação de Índice Remoto** é um operador lógico e físico.| 
|![Operador remote index seek showplan](../relational-databases/media/remote-index-seek-32x.gif "operador remote index seek showplan")|**Remote Index Seek**|O operador de **Busca de Índice Remoto** usa a busca de um objeto de índice remoto para recuperar linhas. A coluna **Argument** contém o nome do índice remoto que está sendo usado e o predicado SEEK:(). **Busca de Índice Remoto** é um operador lógico e físico.| 
|![Ícone do operador Remote insert](../relational-databases/media/remote-insert-32x.gif "Ícone do operador Remote insert")|**Remote Insert**|O operador **Remote Insert** insere linhas de entrada em um objeto remoto. O**Remote Insert** é um operador lógico e físico.| 
|![Ícone do operador Remote query](../relational-databases/media/remote-query-32x.gif "Ícone do operador Remote query")|**Remote Query**|O operador **Remote Query** submete uma consulta a uma fonte remota. O texto da consulta enviado ao servidor remoto aparece na coluna **Argument** . **Remote Query** é um operador lógico e físico.| 
|![Ícone do operador Remote scan](../relational-databases/media/remote-scan-32x.gif "Ícone do operador Remote scan")|**Remote Scan**|O operador **Remote Scan** examina um objeto remoto. O nome do objeto remoto aparece na coluna **Argument** . **Remote Scan** é um operador lógico e físico.| 
|![Ícone do operador Remote update](../relational-databases/media/remote-update-32x.gif "Ícone do operador Remote update")|**Remote Update**|O operador **Remote Update** atualiza a linha de entrada em um objeto remoto. **Remote Update** é um operador lógico e físico.| 
|![Ícone do operador de paralelismo Repartition streams](../relational-databases/media/parallelism-repartition-stream.gif "Ícone do operador de paralelismo Repartition streams")|**Repartition Streams**|O operador **Repartition Streams** (ou iterador de troca) consome vários fluxos e produz vários fluxos de registros. O conteúdo do registro e o formato não são alterados. Se o otimizador de consulta usar um filtro de bitmap, o número de linhas no fluxo de saída será reduzido. Cada registro de um fluxo de entrada é colocado em um fluxo de saída. Se esse operador for preservador de ordem, todos os fluxos de entrada deverão ser ordenados e mesclados em vários fluxos de saída ordenados. Se a saída for particionada, a coluna **Argument** conterá um predicado PARTITION COLUMNS:() e as colunas de particionamento. Se a saída for ordenada, a coluna **Argument** conterá um predicado ORDER BY:() e as colunas que estão sendo ordenadas. **Reparticionar Fluxos** atua como um operador lógico. O operador é usado somente em planos de consulta paralelos.| 
|![Ícone do elemento de linguagem Result](../relational-databases/media/result-32x.gif "Ícone do elemento de linguagem Result")|**Resultado**|O operador **Result** consiste nos dados retornados ao término de um plano de consulta. Normalmente, é o elemento raiz de um plano de execução. **Result** é um elemento de linguagem.| 
|![Ícone do operador RID lookup](../relational-databases/media/rid-nonclust-locate-32x.gif "Ícone do operador RID lookup")|**RID Lookup**|**RID Lookup** é um indicador de pesquisa em um heap que usa um RID (identificador de linha) fornecido. A coluna **Argument** contém o rótulo de indicador usado para pesquisar a linha na tabela e o nome da tabela em que a linha é pesquisada. **RID Lookup** sempre é acompanhado por NESTED LOOP JOIN. **RID Lookup** é um operador físico. Para obter mais informações sobre pesquisas de indicador, consulte o artigo sobre[pesquisa de indicadores](https://go.microsoft.com/fwlink/?LinkId=132568)no blog do SQL Server no MSDN.| 
|![Ícone do operador Row count spool](../relational-databases/media/remote-count-spool-32x.gif "Ícone do operador Row count spool")|**Row Count Spool**|O operador **Row Count Spool** examina a entrada, contando quantas linhas estão presentes e retornando o mesmo número de linhas sem qualquer dado nelas. Esse operador é usado quando é importante a verificação da existência de linhas, em vez dos dados contidos nas linhas. Por exemplo, se um operador **Nested loops** executa uma operação left semi join e o predicado de junção se aplica à entrada interna, um spool de contagem de linhas poderá ser colocado no topo da entrada interna do operador **Nested loops** . Em seguida, o operador **Nested Loops** poderá determinar quantas linhas saem do spool de contagem de linhas (porque não são necessários dados reais do lado interno) para determinar se retornará a linha exterior. O**Row Count Spool** é um operador físico.| 
|Nenhum|**Right Anti Semi Join**|O operador **Right Anti Semi Join** efetua a saída de cada linha a partir da segunda (inferior) entrada quando não existe uma linha correspondente na primeira (superior) entrada. Uma linha correspondente está definida como uma linha que atende ao predicado na coluna **Argument** (se nenhum predicado existir, cada linha será uma linha correspondente). **Right Anti Semi Join** é um operador lógico.| 
|Nenhum|**Right Outer Join**|O operador **Right Outer Join** retorna cada linha que satisfaz a junção da segunda entrada (parte inferior) associada a cada linha correspondente da primeira entrada (parte superior). Ele também retorna linhas da segunda entrada que não tiveram linhas correspondentes na primeira entrada, unidas com NULL. Se não houver nenhum predicado de junção na coluna **Argument** , cada linha será uma linha correspondente. **Right Outer Join** é um operador lógico.| 
|Nenhum|**Right Semi Join**|O operador **Right Semi Join** retornará todas as linha da segunda entrada (inferior) quando existir uma linha correspondente na primeira entrada (superior). Se não houver nenhum predicado de junção na coluna **Argument** , cada linha será uma linha correspondente. **Right Semi Join** é um operador lógico.| 
|![Ícone do operador Segment](../relational-databases/media/segment-32x.gif "Ícone do operador Segment")|**Segment**|**Segment** é um operador lógico e físico. Divide a entrada definida em segmentos baseado no valor de uma ou mais colunas. Essas colunas são mostradas como argumentos no operador **Segment** . O operador produz então um segmento por vez.| 
|![Ícone do operador Sequence](../relational-databases/media/sequence-32x.gif "Ícone do operador Sequence")|**Sequência**|O operador **Sequence** conduz amplos planos de atualização. Em termos funcionais, ele executa cada entrada em sequência (da parte superior até a inferior). Cada entrada normalmente é uma atualização de um objeto diferente. Ele retorna somente as linhas que vêm de sua última entrada (parte inferior). **Sequence** é um operador lógico e físico.| 
|![Ícone do operador Sequence project](../relational-databases/media/sequence-project-32x.gif "Ícone do operador Sequence project")|**Projeto de sequência**|O operador **Sequence Project** adiciona colunas para executar computações sobre um conjunto ordenado. Divide a entrada definida em segmentos baseado no valor de uma ou mais colunas. O operador produz então um segmento por vez. Estas colunas são mostradas como argumentos no operador **Sequence Project** . **Sequence Project** é um operador lógico e físico.| 
|Nenhum|**Segment Repartition**|Às vezes, em um plano de consulta paralelo, há regiões conceituais de iteradores. Todos os iteradores dentro de tal região podem ser executados por threads paralelos. As próprias regiões devem ser executadas em série. Alguns dos iteradores **Parallelism** em uma região individual são chamados **Branch Repartition**. O iterador **Parallelism** no limite dessas duas regiões é chamado **Segment Repartition**. **Branch Repartition** e **Segment Repartition** são operadores lógicos.| 
|![Ícone do operador de cursor Snapshot](../relational-databases/media/snapshot-32x.gif "Ícone do operador de cursor Snapshot")|**Instantâneo**|O operador **Snapshot** cria um cursor que não encontra mudanças feitas pelos outros.| 
|![Ícone do operador Sort](../relational-databases/media/sort-32x.gif "Ícone do operador Sort")|**Sort**|O operador **Sort** classifica todas as linhas de entrada. A coluna **Argument** contém um predicado DISTINCT ORDER BY:() se duplicatas forem removidas por esta operação, ou um predicado ORDER BY:() com uma lista separada por vírgula das colunas que estão sendo classificadas. As colunas são prefixadas com o valor ASC se as colunas forem classificadas em ordem crescente, ou o valor DESC se as colunas forem classificadas em ordem decrescente. **Sort** é um operador lógico e físico.| 
|![Ícone do operador Split](../relational-databases/media/split-32x.gif "Ícone do operador Split")|**Split**|O operador **Split** é usado para otimizar o processamento da atualização. Ele divide cada operação de atualização em uma operação de exclusão e inserção. **Split** é um operador lógico e físico.| 
|![Ícone do operador Spool](../relational-databases/media/spool-32x.gif "Ícone do operador Spool")|**Eager Spool**|O operador **Eager Spool** pega toda a entrada, armazenando cada linha em um objeto temporário oculto armazenado no banco de dados **tempdb** . Se for feito o retrocesso do operador (por exemplo, por um operador **Nested Loops** ) sem que haja necessidade de reassociação, serão usados os dados em spool em vez de um novo exame da entrada. Se a reassociação for necessária, os dados em spool serão descartados e o objeto de spool será recriado por meio do novo exame da entrada (religação). O operador **Eager Spool** cria seu arquivo de spool de maneira “ávida”, ou seja, cada vez que o operador pai do spool solicita a primeira linha, o operador de spool consome todas as linhas de seu operador de entrada e as armazena no spool. O**Eager Spool** é um operador lógico.| 
|![Ícone do operador Spool](../relational-databases/media/spool-32x.gif "Ícone do operador Spool")|**Lazy Spool**|O operador lógico **Lazy Spool** armazena cada linha de sua entrada em um objeto temporário oculto armazenado no banco de dados **tempdb** . Se for feito o retrocesso do operador (por exemplo, por um operador **Nested Loops** ) sem que haja necessidade de reassociação, serão usados os dados em spool em vez de um novo exame da entrada. Se a reassociação for necessária, os dados em spool serão descartados e o objeto de spool será recriado por meio do novo exame da entrada (religação). O operador **Lazy Spool** cria seu arquivo de spool de maneira “lenta”, ou seja, sempre que o operador pai do spool solicita uma linha, o operador do spool obtém uma linha de seu operador de entrada e a armazena no spool, em vez de consumir todas as linhas de uma vez. O Lazy Spool é um operador lógico.| 
|![Ícone do operador Spool](../relational-databases/media/spool-32x.gif "Ícone do operador Spool")|**Spool**|O operador **Spool** salva um resultado de consulta intermediário no banco de dados **tempdb** .| 
|![Ícone do operador Stream aggregate](../relational-databases/media/stream-aggregate-32x.gif "Ícone do operador Stream aggregate")|**Stream Aggregate**|O operador **Stream Aggregate** agrupa linhas por uma ou mais colunas e, em seguida, calcula uma ou mais expressões de agregação retornadas pela consulta. A saída deste operador pode ser referenciada por operadores posteriores na consulta, retornada ao cliente, ou ambos. O operador **Stream Aggregate** requer a entrada de dados ordenada pelas colunas dentro de seus grupos. O otimizador usará um operador **Sort** antes desse operador se os dados ainda não estiverem classificados em função de um operador **Sort** anterior ou devido a uma busca ou análise de índice ordenado. Na instrução SHOWPLAN_ALL ou no plano de execução gráfica no [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)], são listadas as colunas no predicado GROUP BY na coluna **Argument** , e as expressões de agregação são listadas na coluna **Defined Values** . **Stream Aggregate** é um operador físico.| 
|![Ícone do operador Switch](../relational-databases/media/switch-32x.gif "Ícone do operador Switch")|**Switch**|**Switch** é um tipo especial de iterador de concatenação que tem *n* entradas. Uma expressão é associada a cada operador **Switch** . Dependendo do valor retornado da expressão (entre 0 e *n*-1), **Switch** copia o fluxo de entrada apropriado ao fluxo de saída. Um uso de **Switch** é implementar planos de consulta envolvendo cursores de avanço rápido com determinados operadores, como o operador **TOP** . **Switch** é um operador lógico e físico.| 
|![Ícone do operador Table delete](../relational-databases/media/table-delete-32x.gif "Ícone do operador Table delete")|**Table Delete**|O operador físico **Table Delete** exclui linhas da tabela especificadas na coluna **Argument** do plano de execução da consulta.| 
|![Ícone do operador Table insert](../relational-databases/media/table-insert-32x.gif "Ícone do operador Table insert")|**Table Insert**|O operador **Table Insert** insere linhas de sua entrada na tabela especificada na coluna **Argument** do plano de execução de consulta. A coluna **Argument** também contém um predicado SET:(), que indica o valor para o qual cada coluna está definida. Se **Table Insert** não tiver nenhum filho para valores de inserção, então a linha inserida será tirada do próprio operador Insert. **Table Insert** é um operador físico.| 
|![Operador Table merge](../relational-databases/media/table-merge-32x.gif "Operador Table merge")|**Table Merge**|O operador **Table Merge** aplica um fluxo de dados de mesclagem a um heap. O operador exclui, atualiza ou insere linhas na tabela especificada na coluna **Argument** do operador. A operação real executada depende do valor do tempo de execução da coluna **ACTION** especificada na coluna **Argument** do operador. **Table Merge** é um operador físico.| 
|![Ícone do operador Table scan](../relational-databases/media/table-scan-32x.gif "Ícone do operador Table scan")|**Table Scan**|O operador **Table Scan** recupera todas as linhas da tabela especificada na coluna **Argument** do plano de execução da consulta. Se um predicado WHERE:() aparecer na coluna **Argument** , somente as linhas que atenderem ao predicado serão retornadas. **Table Scan** é um operador lógico e físico.| 
|![Ícone do operador Table spool](../relational-databases/media/table-spool-32x.gif "Ícone do operador Table spool")|**Table Spool**|O operador **Table Spool** examina a entrada e coloca uma cópia de cada linha em uma tabela de spool oculta que é armazenada no banco de dados [tempdb](../relational-databases/databases/tempdb-database.md) e existe durante o tempo de vida da consulta. Se for feito o retrocesso do operador (por exemplo, por um operador **Nested Loops** ) sem que haja necessidade de reassociação, serão usados os dados em spool em vez de um novo exame da entrada. **Table Spool** é um operador físico.| 
|![Ícone do operador Table spool](../relational-databases/media/table-spool-32x.gif "Ícone do operador Table spool")|**Window Spool**|O operador **Window Spool** expande cada linha no conjunto de linhas que representa a janela associada a ele. Em uma consulta, a cláusula OVER define a janela em um conjunto de resultados de consulta e uma função de janela, e depois computa um valor para cada linha na janela. **Window Spool** é um operador lógico e físico.| 
|![Ícone do operador Table update](../relational-databases/media/table-update-32x.gif "Ícone do operador Table update")|**Table Update**|O operador físico **Table Update** atualiza linhas de entrada na tabela especificada na coluna **Argument** do plano de execução de consulta. O predicado SET: () determina o valor de cada coluna atualizada. Esses valores podem ser consultados na cláusula SET ou em outro lugar dentro desse operador assim como em outro lugar dessa consulta.| 
|![Ícone do operador Table-valued function](../relational-databases/media/table-valued-function-32x.gif "Ícone do operador Table-valued function")|**Table-valued Function**|O operador **Table-valued Function** avalia uma função com valor de tabela ( [!INCLUDE[tsql](../includes/tsql-md.md)] ou CLR) e armazena as linhas resultantes no banco de dados [tempdb](../relational-databases/databases/tempdb-database.md) . Quando os iteradores pai solicitam as linhas, **Table-valued Function** retorna as linhas de **tempdb**.<br /><br /> As consultas com chamadas às funções com valor de tabela geram planos de consulta com o iterador de **Table-valued Function** . **Table-valued Function** pode ser avaliada com valores de parâmetros diferentes:<br /><br /> -<br /> O**Leitor de XML da Função com valor de tabela** insere um BLOB XML como parâmetro e processa um conjunto de linhas representando os nós XML na ordem dos documentos XML. Outros parâmetros de entrada podem restringir os nós XML retornados a um subconjunto de documentos XML.<br /><br /> -**Leitor de XML da Função com valor de tabela com filtro XPath** é um tipo especial de **Função com valor de tabela do Leitor de XML** que restringe a saída a nós XML que atendem a uma expressão XPath.<br /><br /> **Table-valued Function** é um operador lógico e físico.| 
|Nenhum|**Top N Sort**|**Top N Sort** é semelhante ao iterador **Classificar** , com exceção de que somente as primeiras *N* linhas são necessárias e não todo o conjunto de resultados. Para valores pequenos de *N*, o mecanismo de execução de consultas do [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] tenta executar toda a operação de classificação na memória. Para valores grandes de *N*, o mecanismo de execução de consultas recorre a um método de classificação mais genérico para o qual *N* não é um parâmetro.| 
|![Ícone do operador Top](../relational-databases/media/top-32x.gif "Ícone do operador Top")|**Top**|O operador **Top** verifica a entrada, retornando só o primeiro número ou porcentagem de linhas especificado, possivelmente com base em uma ordem de classificação. A coluna **Argument** pode conter uma lista das colunas cujas associações estão sendo verificadas. Em planos de atualização, o operador **Top** é usado para aplicar os limites de contagem de linhas. **Top** é um operador lógico e físico.| 
|![Ícone do operador Extended (UDX)](../relational-databases/media/udx-32x.gif "Ícone do operador Extended (UDX)")|**UDX**|Operadores estendidos (UDX) implementam uma de muitas operações XQuery e XPATH no [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]. Todos os operadores UDX são classificados como operadores lógicos e físicos.<br /><br /> O operador estendido (UDX) **FOR XML** é usado para serializar o conjunto relacional de linhas e insere em representação XML em uma única coluna BLOB, e em uma única linha de saída. É um operador de agregação XML sensível à ordenação.<br /><br /> O operador estendido (UDX) **XML SERIALIZER** é um operador de agregação XML sensível à ordenação. Ele insere linhas que representam nós XML ou escalares de XQuery em ordem de documento XML e produz um XML BLOB serializado em uma única coluna XML em uma única linha de saída.<br /><br /> O operador estendido (UDX) **XML FRAGMENT SERIALIZER** é um tipo especial de **XML SERIALIZER** que é usado para processar linhas de entrada que representam fragmentos de XML que são inseridos na extensão de modificação de dados de inserção de XQuery.<br /><br /> O operador estendido (UDX) **XQUERY STRING** avalia o valor da cadeia de caracteres XQuery das linhas de entrada que representam nós de XML. É um operador de agregação de cadeia sensível à ordenação. Produz uma linha com colunas que representam o escalar de XQuery que contém o valor de cadeia de caracteres da entrada.<br /><br /> O operador estendido (UDX) **XQUERY LIST DECOMPOSER** é um operador de decomposição de lista do XQuery. Para cada linha de entrada que representa um nó de XML ele produz uma ou mais linhas, cada uma representando o escalar de Xquery, que contém um valor de elemento de lista caso a entrada seja do tipo lista de XSD.<br /><br /> O operador estendido (UDX) **XQUERY DATA** avalia a função XQuery fn:data() na entrada que representa os nós XML. É um operador de agregação de cadeia sensível à ordenação. Ele produz uma linha com colunas que representam o escalar de XQuery que contém o resultado de **fn:data()** .<br /><br /> O operador estendido **XQUERY CONTAINS** avalia a função XQuery fn:contains() na entrada que representa os nós XML. É um operador de agregação de cadeia sensível à ordenação. Ele produz uma linha com colunas que representam o escalar de XQuery que contém o resultado de **fn:contains()** .<br /><br /> O operador estendido **UPDATE XML NODE** atualiza o nó XML na extensão de modificação de dados de substituição XQuery no método **modify()** no tipo XML.| 
|Nenhum|**Union**|O operador **Union** verifica várias entradas, gerando a saída de cada linha examinada e removendo duplicatas. **Union** é um operador lógico.| 
|![Ícone do operador Update (mecanismo de banco de dados)](../relational-databases/media/update-32x.gif "Ícone do operador Update (mecanismo de banco de dados)")|**Atualização**|O operador **Update** atualiza cada linha de sua entrada no objeto especificado na coluna **Argument** do plano de execução de consulta. **Update** é um operador lógico. O operador físico é **Table Update**, **Index Update**ou **Clustered Index Update**.| 
|![Ícone do elemento de linguagem While](../relational-databases/media/while-32x.gif "Ícone do elemento de linguagem While")|**While**|O operador **While** implementa [!INCLUDE[tsql](../includes/tsql-md.md)] durante o loop. **While** é um elemento de linguagem| 
  
